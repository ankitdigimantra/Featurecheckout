"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/async-validator";
exports.ids = ["vendor-chunks/async-validator"];
exports.modules = {

/***/ "(ssr)/../../../node_modules/async-validator/dist-web/index.js":
/*!***************************************************************!*\
  !*** ../../../node_modules/async-validator/dist-web/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Schema)\n/* harmony export */ });\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    _setPrototypeOf(subClass, superClass);\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction _construct(Parent, args, Class) {\n    if (_isNativeReflectConstruct()) {\n        _construct = Reflect.construct.bind();\n    } else {\n        _construct = function _construct(Parent, args, Class) {\n            var a = [\n                null\n            ];\n            a.push.apply(a, args);\n            var Constructor = Function.bind.apply(Parent, a);\n            var instance = new Constructor();\n            if (Class) _setPrototypeOf(instance, Class.prototype);\n            return instance;\n        };\n    }\n    return _construct.apply(null, arguments);\n}\nfunction _isNativeFunction(fn) {\n    return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\nfunction _wrapNativeSuper(Class) {\n    var _cache = typeof Map === \"function\" ? new Map() : undefined;\n    _wrapNativeSuper = function _wrapNativeSuper(Class) {\n        if (Class === null || !_isNativeFunction(Class)) return Class;\n        if (typeof Class !== \"function\") {\n            throw new TypeError(\"Super expression must either be null or a function\");\n        }\n        if (typeof _cache !== \"undefined\") {\n            if (_cache.has(Class)) return _cache.get(Class);\n            _cache.set(Class, Wrapper);\n        }\n        function Wrapper() {\n            return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n        }\n        Wrapper.prototype = Object.create(Class.prototype, {\n            constructor: {\n                value: Wrapper,\n                enumerable: false,\n                writable: true,\n                configurable: true\n            }\n        });\n        return _setPrototypeOf(Wrapper, Class);\n    };\n    return _wrapNativeSuper(Class);\n}\n/* eslint no-console:0 */ var formatRegExp = /%[sdj%]/g;\nvar warning = function warning() {}; // don't print warning message when in production env or node runtime\nif (typeof process !== \"undefined\" && process.env && \"development\" !== \"production\" && \"undefined\" !== \"undefined\" && 0) {}\nfunction convertFieldsError(errors) {\n    if (!errors || !errors.length) return null;\n    var fields = {};\n    errors.forEach(function(error) {\n        var field = error.field;\n        fields[field] = fields[field] || [];\n        fields[field].push(error);\n    });\n    return fields;\n}\nfunction format(template) {\n    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        args[_key - 1] = arguments[_key];\n    }\n    var i = 0;\n    var len = args.length;\n    if (typeof template === \"function\") {\n        return template.apply(null, args);\n    }\n    if (typeof template === \"string\") {\n        var str = template.replace(formatRegExp, function(x) {\n            if (x === \"%%\") {\n                return \"%\";\n            }\n            if (i >= len) {\n                return x;\n            }\n            switch(x){\n                case \"%s\":\n                    return String(args[i++]);\n                case \"%d\":\n                    return Number(args[i++]);\n                case \"%j\":\n                    try {\n                        return JSON.stringify(args[i++]);\n                    } catch (_) {\n                        return \"[Circular]\";\n                    }\n                    break;\n                default:\n                    return x;\n            }\n        });\n        return str;\n    }\n    return template;\n}\nfunction isNativeStringType(type) {\n    return type === \"string\" || type === \"url\" || type === \"hex\" || type === \"email\" || type === \"date\" || type === \"pattern\";\n}\nfunction isEmptyValue(value, type) {\n    if (value === undefined || value === null) {\n        return true;\n    }\n    if (type === \"array\" && Array.isArray(value) && !value.length) {\n        return true;\n    }\n    if (isNativeStringType(type) && typeof value === \"string\" && !value) {\n        return true;\n    }\n    return false;\n}\nfunction asyncParallelArray(arr, func, callback) {\n    var results = [];\n    var total = 0;\n    var arrLength = arr.length;\n    function count(errors) {\n        results.push.apply(results, errors || []);\n        total++;\n        if (total === arrLength) {\n            callback(results);\n        }\n    }\n    arr.forEach(function(a) {\n        func(a, count);\n    });\n}\nfunction asyncSerialArray(arr, func, callback) {\n    var index = 0;\n    var arrLength = arr.length;\n    function next(errors) {\n        if (errors && errors.length) {\n            callback(errors);\n            return;\n        }\n        var original = index;\n        index = index + 1;\n        if (original < arrLength) {\n            func(arr[original], next);\n        } else {\n            callback([]);\n        }\n    }\n    next([]);\n}\nfunction flattenObjArr(objArr) {\n    var ret = [];\n    Object.keys(objArr).forEach(function(k) {\n        ret.push.apply(ret, objArr[k] || []);\n    });\n    return ret;\n}\nvar AsyncValidationError = /*#__PURE__*/ function(_Error) {\n    _inheritsLoose(AsyncValidationError, _Error);\n    function AsyncValidationError(errors, fields) {\n        var _this;\n        _this = _Error.call(this, \"Async Validation Error\") || this;\n        _this.errors = errors;\n        _this.fields = fields;\n        return _this;\n    }\n    return AsyncValidationError;\n}(/*#__PURE__*/ _wrapNativeSuper(Error));\nfunction asyncMap(objArr, option, func, callback, source) {\n    if (option.first) {\n        var _pending = new Promise(function(resolve, reject) {\n            var next = function next(errors) {\n                callback(errors);\n                return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);\n            };\n            var flattenArr = flattenObjArr(objArr);\n            asyncSerialArray(flattenArr, func, next);\n        });\n        _pending[\"catch\"](function(e) {\n            return e;\n        });\n        return _pending;\n    }\n    var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];\n    var objArrKeys = Object.keys(objArr);\n    var objArrLength = objArrKeys.length;\n    var total = 0;\n    var results = [];\n    var pending = new Promise(function(resolve, reject) {\n        var next = function next(errors) {\n            results.push.apply(results, errors);\n            total++;\n            if (total === objArrLength) {\n                callback(results);\n                return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);\n            }\n        };\n        if (!objArrKeys.length) {\n            callback(results);\n            resolve(source);\n        }\n        objArrKeys.forEach(function(key) {\n            var arr = objArr[key];\n            if (firstFields.indexOf(key) !== -1) {\n                asyncSerialArray(arr, func, next);\n            } else {\n                asyncParallelArray(arr, func, next);\n            }\n        });\n    });\n    pending[\"catch\"](function(e) {\n        return e;\n    });\n    return pending;\n}\nfunction isErrorObj(obj) {\n    return !!(obj && obj.message !== undefined);\n}\nfunction getValue(value, path) {\n    var v = value;\n    for(var i = 0; i < path.length; i++){\n        if (v == undefined) {\n            return v;\n        }\n        v = v[path[i]];\n    }\n    return v;\n}\nfunction complementError(rule, source) {\n    return function(oe) {\n        var fieldValue;\n        if (rule.fullFields) {\n            fieldValue = getValue(source, rule.fullFields);\n        } else {\n            fieldValue = source[oe.field || rule.fullField];\n        }\n        if (isErrorObj(oe)) {\n            oe.field = oe.field || rule.fullField;\n            oe.fieldValue = fieldValue;\n            return oe;\n        }\n        return {\n            message: typeof oe === \"function\" ? oe() : oe,\n            fieldValue: fieldValue,\n            field: oe.field || rule.fullField\n        };\n    };\n}\nfunction deepMerge(target, source) {\n    if (source) {\n        for(var s in source){\n            if (source.hasOwnProperty(s)) {\n                var value = source[s];\n                if (typeof value === \"object\" && typeof target[s] === \"object\") {\n                    target[s] = _extends({}, target[s], value);\n                } else {\n                    target[s] = value;\n                }\n            }\n        }\n    }\n    return target;\n}\nvar required$1 = function required(rule, value, source, errors, options, type) {\n    if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type || rule.type))) {\n        errors.push(format(options.messages.required, rule.fullField));\n    }\n};\n/**\n *  Rule for validating whitespace.\n *\n *  @param rule The validation rule.\n *  @param value The value of the field on the source object.\n *  @param source The source object being validated.\n *  @param errors An array of errors that this rule may add\n *  validation errors to.\n *  @param options The validation options.\n *  @param options.messages The validation messages.\n */ var whitespace = function whitespace(rule, value, source, errors, options) {\n    if (/^\\s+$/.test(value) || value === \"\") {\n        errors.push(format(options.messages.whitespace, rule.fullField));\n    }\n};\n// https://github.com/kevva/url-regex/blob/master/index.js\nvar urlReg;\nvar getUrlRegex = function() {\n    if (urlReg) {\n        return urlReg;\n    }\n    var word = \"[a-fA-F\\\\d:]\";\n    var b = function b(options) {\n        return options && options.includeBoundaries ? \"(?:(?<=\\\\s|^)(?=\" + word + \")|(?<=\" + word + \")(?=\\\\s|$))\" : \"\";\n    };\n    var v4 = \"(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}\";\n    var v6seg = \"[a-fA-F\\\\d]{1,4}\";\n    var v6 = (\"\\n(?:\\n(?:\" + v6seg + \":){7}(?:\" + v6seg + \"|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\\n(?:\" + v6seg + \":){6}(?:\" + v4 + \"|:\" + v6seg + \"|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\\n(?:\" + v6seg + \":){5}(?::\" + v4 + \"|(?::\" + v6seg + \"){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\\n(?:\" + v6seg + \":){4}(?:(?::\" + v6seg + \"){0,1}:\" + v4 + \"|(?::\" + v6seg + \"){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\\n(?:\" + v6seg + \":){3}(?:(?::\" + v6seg + \"){0,2}:\" + v4 + \"|(?::\" + v6seg + \"){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\\n(?:\" + v6seg + \":){2}(?:(?::\" + v6seg + \"){0,3}:\" + v4 + \"|(?::\" + v6seg + \"){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\\n(?:\" + v6seg + \":){1}(?:(?::\" + v6seg + \"){0,4}:\" + v4 + \"|(?::\" + v6seg + \"){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\\n(?::(?:(?::\" + v6seg + \"){0,5}:\" + v4 + \"|(?::\" + v6seg + \"){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\\n\").replace(/\\s*\\/\\/.*$/gm, \"\").replace(/\\n/g, \"\").trim(); // Pre-compile only the exact regexes because adding a global flag make regexes stateful\n    var v46Exact = new RegExp(\"(?:^\" + v4 + \"$)|(?:^\" + v6 + \"$)\");\n    var v4exact = new RegExp(\"^\" + v4 + \"$\");\n    var v6exact = new RegExp(\"^\" + v6 + \"$\");\n    var ip = function ip(options) {\n        return options && options.exact ? v46Exact : new RegExp(\"(?:\" + b(options) + v4 + b(options) + \")|(?:\" + b(options) + v6 + b(options) + \")\", \"g\");\n    };\n    ip.v4 = function(options) {\n        return options && options.exact ? v4exact : new RegExp(\"\" + b(options) + v4 + b(options), \"g\");\n    };\n    ip.v6 = function(options) {\n        return options && options.exact ? v6exact : new RegExp(\"\" + b(options) + v6 + b(options), \"g\");\n    };\n    var protocol = \"(?:(?:[a-z]+:)?//)\";\n    var auth = \"(?:\\\\S+(?::\\\\S*)?@)?\";\n    var ipv4 = ip.v4().source;\n    var ipv6 = ip.v6().source;\n    var host = \"(?:(?:[a-z\\\\u00a1-\\\\uffff0-9][-_]*)*[a-z\\\\u00a1-\\\\uffff0-9]+)\";\n    var domain = \"(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*\";\n    var tld = \"(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,}))\";\n    var port = \"(?::\\\\d{2,5})?\";\n    var path = '(?:[/?#][^\\\\s\"]*)?';\n    var regex = \"(?:\" + protocol + \"|www\\\\.)\" + auth + \"(?:localhost|\" + ipv4 + \"|\" + ipv6 + \"|\" + host + domain + tld + \")\" + port + path;\n    urlReg = new RegExp(\"(?:^\" + regex + \"$)\", \"i\");\n    return urlReg;\n};\n/* eslint max-len:0 */ var pattern$2 = {\n    // http://emailregex.com/\n    email: /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]+\\.)+[a-zA-Z\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]{2,}))$/,\n    // url: new RegExp(\n    //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\\\S+(?::\\\\S*)?@)?(?:(?:(?:[1-9]\\\\d?|1\\\\d\\\\d|2[01]\\\\d|22[0-3])(?:\\\\.(?:1?\\\\d{1,2}|2[0-4]\\\\d|25[0-5])){2}(?:\\\\.(?:[0-9]\\\\d?|1\\\\d\\\\d|2[0-4]\\\\d|25[0-4]))|(?:(?:[a-z\\\\u00a1-\\\\uffff0-9]+-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]+-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,})))|localhost)(?::\\\\d{2,5})?(?:(/|\\\\?|#)[^\\\\s]*)?$',\n    //   'i',\n    // ),\n    hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i\n};\nvar types = {\n    integer: function integer(value) {\n        return types.number(value) && parseInt(value, 10) === value;\n    },\n    \"float\": function float(value) {\n        return types.number(value) && !types.integer(value);\n    },\n    array: function array(value) {\n        return Array.isArray(value);\n    },\n    regexp: function regexp(value) {\n        if (value instanceof RegExp) {\n            return true;\n        }\n        try {\n            return !!new RegExp(value);\n        } catch (e) {\n            return false;\n        }\n    },\n    date: function date(value) {\n        return typeof value.getTime === \"function\" && typeof value.getMonth === \"function\" && typeof value.getYear === \"function\" && !isNaN(value.getTime());\n    },\n    number: function number(value) {\n        if (isNaN(value)) {\n            return false;\n        }\n        return typeof value === \"number\";\n    },\n    object: function object(value) {\n        return typeof value === \"object\" && !types.array(value);\n    },\n    method: function method(value) {\n        return typeof value === \"function\";\n    },\n    email: function email(value) {\n        return typeof value === \"string\" && value.length <= 320 && !!value.match(pattern$2.email);\n    },\n    url: function url(value) {\n        return typeof value === \"string\" && value.length <= 2048 && !!value.match(getUrlRegex());\n    },\n    hex: function hex(value) {\n        return typeof value === \"string\" && !!value.match(pattern$2.hex);\n    }\n};\nvar type$1 = function type(rule, value, source, errors, options) {\n    if (rule.required && value === undefined) {\n        required$1(rule, value, source, errors, options);\n        return;\n    }\n    var custom = [\n        \"integer\",\n        \"float\",\n        \"array\",\n        \"regexp\",\n        \"object\",\n        \"method\",\n        \"email\",\n        \"number\",\n        \"date\",\n        \"url\",\n        \"hex\"\n    ];\n    var ruleType = rule.type;\n    if (custom.indexOf(ruleType) > -1) {\n        if (!types[ruleType](value)) {\n            errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));\n        } // straight typeof check\n    } else if (ruleType && typeof value !== rule.type) {\n        errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));\n    }\n};\nvar range = function range(rule, value, source, errors, options) {\n    var len = typeof rule.len === \"number\";\n    var min = typeof rule.min === \"number\";\n    var max = typeof rule.max === \"number\"; // 正则匹配码点范围从U+010000一直到U+10FFFF的文字（补充平面Supplementary Plane）\n    var spRegexp = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n    var val = value;\n    var key = null;\n    var num = typeof value === \"number\";\n    var str = typeof value === \"string\";\n    var arr = Array.isArray(value);\n    if (num) {\n        key = \"number\";\n    } else if (str) {\n        key = \"string\";\n    } else if (arr) {\n        key = \"array\";\n    } // if the value is not of a supported type for range validation\n    // the validation rule rule should use the\n    // type property to also test for a particular type\n    if (!key) {\n        return false;\n    }\n    if (arr) {\n        val = value.length;\n    }\n    if (str) {\n        // 处理码点大于U+010000的文字length属性不准确的bug，如\"𠮷𠮷𠮷\".lenght !== 3\n        val = value.replace(spRegexp, \"_\").length;\n    }\n    if (len) {\n        if (val !== rule.len) {\n            errors.push(format(options.messages[key].len, rule.fullField, rule.len));\n        }\n    } else if (min && !max && val < rule.min) {\n        errors.push(format(options.messages[key].min, rule.fullField, rule.min));\n    } else if (max && !min && val > rule.max) {\n        errors.push(format(options.messages[key].max, rule.fullField, rule.max));\n    } else if (min && max && (val < rule.min || val > rule.max)) {\n        errors.push(format(options.messages[key].range, rule.fullField, rule.min, rule.max));\n    }\n};\nvar ENUM$1 = \"enum\";\nvar enumerable$1 = function enumerable(rule, value, source, errors, options) {\n    rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];\n    if (rule[ENUM$1].indexOf(value) === -1) {\n        errors.push(format(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(\", \")));\n    }\n};\nvar pattern$1 = function pattern(rule, value, source, errors, options) {\n    if (rule.pattern) {\n        if (rule.pattern instanceof RegExp) {\n            // if a RegExp instance is passed, reset `lastIndex` in case its `global`\n            // flag is accidentally set to `true`, which in a validation scenario\n            // is not necessary and the result might be misleading\n            rule.pattern.lastIndex = 0;\n            if (!rule.pattern.test(value)) {\n                errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));\n            }\n        } else if (typeof rule.pattern === \"string\") {\n            var _pattern = new RegExp(rule.pattern);\n            if (!_pattern.test(value)) {\n                errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));\n            }\n        }\n    }\n};\nvar rules = {\n    required: required$1,\n    whitespace: whitespace,\n    type: type$1,\n    range: range,\n    \"enum\": enumerable$1,\n    pattern: pattern$1\n};\nvar string = function string(rule, value, callback, source, options) {\n    var errors = [];\n    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n    if (validate) {\n        if (isEmptyValue(value, \"string\") && !rule.required) {\n            return callback();\n        }\n        rules.required(rule, value, source, errors, options, \"string\");\n        if (!isEmptyValue(value, \"string\")) {\n            rules.type(rule, value, source, errors, options);\n            rules.range(rule, value, source, errors, options);\n            rules.pattern(rule, value, source, errors, options);\n            if (rule.whitespace === true) {\n                rules.whitespace(rule, value, source, errors, options);\n            }\n        }\n    }\n    callback(errors);\n};\nvar method = function method(rule, value, callback, source, options) {\n    var errors = [];\n    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n    if (validate) {\n        if (isEmptyValue(value) && !rule.required) {\n            return callback();\n        }\n        rules.required(rule, value, source, errors, options);\n        if (value !== undefined) {\n            rules.type(rule, value, source, errors, options);\n        }\n    }\n    callback(errors);\n};\nvar number = function number(rule, value, callback, source, options) {\n    var errors = [];\n    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n    if (validate) {\n        if (value === \"\") {\n            value = undefined;\n        }\n        if (isEmptyValue(value) && !rule.required) {\n            return callback();\n        }\n        rules.required(rule, value, source, errors, options);\n        if (value !== undefined) {\n            rules.type(rule, value, source, errors, options);\n            rules.range(rule, value, source, errors, options);\n        }\n    }\n    callback(errors);\n};\nvar _boolean = function _boolean(rule, value, callback, source, options) {\n    var errors = [];\n    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n    if (validate) {\n        if (isEmptyValue(value) && !rule.required) {\n            return callback();\n        }\n        rules.required(rule, value, source, errors, options);\n        if (value !== undefined) {\n            rules.type(rule, value, source, errors, options);\n        }\n    }\n    callback(errors);\n};\nvar regexp = function regexp(rule, value, callback, source, options) {\n    var errors = [];\n    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n    if (validate) {\n        if (isEmptyValue(value) && !rule.required) {\n            return callback();\n        }\n        rules.required(rule, value, source, errors, options);\n        if (!isEmptyValue(value)) {\n            rules.type(rule, value, source, errors, options);\n        }\n    }\n    callback(errors);\n};\nvar integer = function integer(rule, value, callback, source, options) {\n    var errors = [];\n    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n    if (validate) {\n        if (isEmptyValue(value) && !rule.required) {\n            return callback();\n        }\n        rules.required(rule, value, source, errors, options);\n        if (value !== undefined) {\n            rules.type(rule, value, source, errors, options);\n            rules.range(rule, value, source, errors, options);\n        }\n    }\n    callback(errors);\n};\nvar floatFn = function floatFn(rule, value, callback, source, options) {\n    var errors = [];\n    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n    if (validate) {\n        if (isEmptyValue(value) && !rule.required) {\n            return callback();\n        }\n        rules.required(rule, value, source, errors, options);\n        if (value !== undefined) {\n            rules.type(rule, value, source, errors, options);\n            rules.range(rule, value, source, errors, options);\n        }\n    }\n    callback(errors);\n};\nvar array = function array(rule, value, callback, source, options) {\n    var errors = [];\n    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n    if (validate) {\n        if ((value === undefined || value === null) && !rule.required) {\n            return callback();\n        }\n        rules.required(rule, value, source, errors, options, \"array\");\n        if (value !== undefined && value !== null) {\n            rules.type(rule, value, source, errors, options);\n            rules.range(rule, value, source, errors, options);\n        }\n    }\n    callback(errors);\n};\nvar object = function object(rule, value, callback, source, options) {\n    var errors = [];\n    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n    if (validate) {\n        if (isEmptyValue(value) && !rule.required) {\n            return callback();\n        }\n        rules.required(rule, value, source, errors, options);\n        if (value !== undefined) {\n            rules.type(rule, value, source, errors, options);\n        }\n    }\n    callback(errors);\n};\nvar ENUM = \"enum\";\nvar enumerable = function enumerable(rule, value, callback, source, options) {\n    var errors = [];\n    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n    if (validate) {\n        if (isEmptyValue(value) && !rule.required) {\n            return callback();\n        }\n        rules.required(rule, value, source, errors, options);\n        if (value !== undefined) {\n            rules[ENUM](rule, value, source, errors, options);\n        }\n    }\n    callback(errors);\n};\nvar pattern = function pattern(rule, value, callback, source, options) {\n    var errors = [];\n    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n    if (validate) {\n        if (isEmptyValue(value, \"string\") && !rule.required) {\n            return callback();\n        }\n        rules.required(rule, value, source, errors, options);\n        if (!isEmptyValue(value, \"string\")) {\n            rules.pattern(rule, value, source, errors, options);\n        }\n    }\n    callback(errors);\n};\nvar date = function date(rule, value, callback, source, options) {\n    // console.log('integer rule called %j', rule);\n    var errors = [];\n    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field); // console.log('validate on %s value', value);\n    if (validate) {\n        if (isEmptyValue(value, \"date\") && !rule.required) {\n            return callback();\n        }\n        rules.required(rule, value, source, errors, options);\n        if (!isEmptyValue(value, \"date\")) {\n            var dateObject;\n            if (value instanceof Date) {\n                dateObject = value;\n            } else {\n                dateObject = new Date(value);\n            }\n            rules.type(rule, dateObject, source, errors, options);\n            if (dateObject) {\n                rules.range(rule, dateObject.getTime(), source, errors, options);\n            }\n        }\n    }\n    callback(errors);\n};\nvar required = function required(rule, value, callback, source, options) {\n    var errors = [];\n    var type = Array.isArray(value) ? \"array\" : typeof value;\n    rules.required(rule, value, source, errors, options, type);\n    callback(errors);\n};\nvar type = function type(rule, value, callback, source, options) {\n    var ruleType = rule.type;\n    var errors = [];\n    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n    if (validate) {\n        if (isEmptyValue(value, ruleType) && !rule.required) {\n            return callback();\n        }\n        rules.required(rule, value, source, errors, options, ruleType);\n        if (!isEmptyValue(value, ruleType)) {\n            rules.type(rule, value, source, errors, options);\n        }\n    }\n    callback(errors);\n};\nvar any = function any(rule, value, callback, source, options) {\n    var errors = [];\n    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n    if (validate) {\n        if (isEmptyValue(value) && !rule.required) {\n            return callback();\n        }\n        rules.required(rule, value, source, errors, options);\n    }\n    callback(errors);\n};\nvar validators = {\n    string: string,\n    method: method,\n    number: number,\n    \"boolean\": _boolean,\n    regexp: regexp,\n    integer: integer,\n    \"float\": floatFn,\n    array: array,\n    object: object,\n    \"enum\": enumerable,\n    pattern: pattern,\n    date: date,\n    url: type,\n    hex: type,\n    email: type,\n    required: required,\n    any: any\n};\nfunction newMessages() {\n    return {\n        \"default\": \"Validation error on field %s\",\n        required: \"%s is required\",\n        \"enum\": \"%s must be one of %s\",\n        whitespace: \"%s cannot be empty\",\n        date: {\n            format: \"%s date %s is invalid for format %s\",\n            parse: \"%s date could not be parsed, %s is invalid \",\n            invalid: \"%s date %s is invalid\"\n        },\n        types: {\n            string: \"%s is not a %s\",\n            method: \"%s is not a %s (function)\",\n            array: \"%s is not an %s\",\n            object: \"%s is not an %s\",\n            number: \"%s is not a %s\",\n            date: \"%s is not a %s\",\n            \"boolean\": \"%s is not a %s\",\n            integer: \"%s is not an %s\",\n            \"float\": \"%s is not a %s\",\n            regexp: \"%s is not a valid %s\",\n            email: \"%s is not a valid %s\",\n            url: \"%s is not a valid %s\",\n            hex: \"%s is not a valid %s\"\n        },\n        string: {\n            len: \"%s must be exactly %s characters\",\n            min: \"%s must be at least %s characters\",\n            max: \"%s cannot be longer than %s characters\",\n            range: \"%s must be between %s and %s characters\"\n        },\n        number: {\n            len: \"%s must equal %s\",\n            min: \"%s cannot be less than %s\",\n            max: \"%s cannot be greater than %s\",\n            range: \"%s must be between %s and %s\"\n        },\n        array: {\n            len: \"%s must be exactly %s in length\",\n            min: \"%s cannot be less than %s in length\",\n            max: \"%s cannot be greater than %s in length\",\n            range: \"%s must be between %s and %s in length\"\n        },\n        pattern: {\n            mismatch: \"%s value %s does not match pattern %s\"\n        },\n        clone: function clone() {\n            var cloned = JSON.parse(JSON.stringify(this));\n            cloned.clone = this.clone;\n            return cloned;\n        }\n    };\n}\nvar messages = newMessages();\n/**\n *  Encapsulates a validation schema.\n *\n *  @param descriptor An object declaring validation rules\n *  for this schema.\n */ var Schema = /*#__PURE__*/ function() {\n    // ========================= Static =========================\n    // ======================== Instance ========================\n    function Schema(descriptor) {\n        this.rules = null;\n        this._messages = messages;\n        this.define(descriptor);\n    }\n    var _proto = Schema.prototype;\n    _proto.define = function define(rules) {\n        var _this = this;\n        if (!rules) {\n            throw new Error(\"Cannot configure a schema with no rules\");\n        }\n        if (typeof rules !== \"object\" || Array.isArray(rules)) {\n            throw new Error(\"Rules must be an object\");\n        }\n        this.rules = {};\n        Object.keys(rules).forEach(function(name) {\n            var item = rules[name];\n            _this.rules[name] = Array.isArray(item) ? item : [\n                item\n            ];\n        });\n    };\n    _proto.messages = function messages(_messages) {\n        if (_messages) {\n            this._messages = deepMerge(newMessages(), _messages);\n        }\n        return this._messages;\n    };\n    _proto.validate = function validate(source_, o, oc) {\n        var _this2 = this;\n        if (o === void 0) {\n            o = {};\n        }\n        if (oc === void 0) {\n            oc = function oc() {};\n        }\n        var source = source_;\n        var options = o;\n        var callback = oc;\n        if (typeof options === \"function\") {\n            callback = options;\n            options = {};\n        }\n        if (!this.rules || Object.keys(this.rules).length === 0) {\n            if (callback) {\n                callback(null, source);\n            }\n            return Promise.resolve(source);\n        }\n        function complete(results) {\n            var errors = [];\n            var fields = {};\n            function add(e) {\n                if (Array.isArray(e)) {\n                    var _errors;\n                    errors = (_errors = errors).concat.apply(_errors, e);\n                } else {\n                    errors.push(e);\n                }\n            }\n            for(var i = 0; i < results.length; i++){\n                add(results[i]);\n            }\n            if (!errors.length) {\n                callback(null, source);\n            } else {\n                fields = convertFieldsError(errors);\n                callback(errors, fields);\n            }\n        }\n        if (options.messages) {\n            var messages$1 = this.messages();\n            if (messages$1 === messages) {\n                messages$1 = newMessages();\n            }\n            deepMerge(messages$1, options.messages);\n            options.messages = messages$1;\n        } else {\n            options.messages = this.messages();\n        }\n        var series = {};\n        var keys = options.keys || Object.keys(this.rules);\n        keys.forEach(function(z) {\n            var arr = _this2.rules[z];\n            var value = source[z];\n            arr.forEach(function(r) {\n                var rule = r;\n                if (typeof rule.transform === \"function\") {\n                    if (source === source_) {\n                        source = _extends({}, source);\n                    }\n                    value = source[z] = rule.transform(value);\n                }\n                if (typeof rule === \"function\") {\n                    rule = {\n                        validator: rule\n                    };\n                } else {\n                    rule = _extends({}, rule);\n                } // Fill validator. Skip if nothing need to validate\n                rule.validator = _this2.getValidationMethod(rule);\n                if (!rule.validator) {\n                    return;\n                }\n                rule.field = z;\n                rule.fullField = rule.fullField || z;\n                rule.type = _this2.getType(rule);\n                series[z] = series[z] || [];\n                series[z].push({\n                    rule: rule,\n                    value: value,\n                    source: source,\n                    field: z\n                });\n            });\n        });\n        var errorFields = {};\n        return asyncMap(series, options, function(data, doIt) {\n            var rule = data.rule;\n            var deep = (rule.type === \"object\" || rule.type === \"array\") && (typeof rule.fields === \"object\" || typeof rule.defaultField === \"object\");\n            deep = deep && (rule.required || !rule.required && data.value);\n            rule.field = data.field;\n            function addFullField(key, schema) {\n                return _extends({}, schema, {\n                    fullField: rule.fullField + \".\" + key,\n                    fullFields: rule.fullFields ? [].concat(rule.fullFields, [\n                        key\n                    ]) : [\n                        key\n                    ]\n                });\n            }\n            function cb(e) {\n                if (e === void 0) {\n                    e = [];\n                }\n                var errorList = Array.isArray(e) ? e : [\n                    e\n                ];\n                if (!options.suppressWarning && errorList.length) {\n                    Schema.warning(\"async-validator:\", errorList);\n                }\n                if (errorList.length && rule.message !== undefined) {\n                    errorList = [].concat(rule.message);\n                } // Fill error info\n                var filledErrors = errorList.map(complementError(rule, source));\n                if (options.first && filledErrors.length) {\n                    errorFields[rule.field] = 1;\n                    return doIt(filledErrors);\n                }\n                if (!deep) {\n                    doIt(filledErrors);\n                } else {\n                    // if rule is required but the target object\n                    // does not exist fail at the rule level and don't\n                    // go deeper\n                    if (rule.required && !data.value) {\n                        if (rule.message !== undefined) {\n                            filledErrors = [].concat(rule.message).map(complementError(rule, source));\n                        } else if (options.error) {\n                            filledErrors = [\n                                options.error(rule, format(options.messages.required, rule.field))\n                            ];\n                        }\n                        return doIt(filledErrors);\n                    }\n                    var fieldsSchema = {};\n                    if (rule.defaultField) {\n                        Object.keys(data.value).map(function(key) {\n                            fieldsSchema[key] = rule.defaultField;\n                        });\n                    }\n                    fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);\n                    var paredFieldsSchema = {};\n                    Object.keys(fieldsSchema).forEach(function(field) {\n                        var fieldSchema = fieldsSchema[field];\n                        var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [\n                            fieldSchema\n                        ];\n                        paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));\n                    });\n                    var schema = new Schema(paredFieldsSchema);\n                    schema.messages(options.messages);\n                    if (data.rule.options) {\n                        data.rule.options.messages = options.messages;\n                        data.rule.options.error = options.error;\n                    }\n                    schema.validate(data.value, data.rule.options || options, function(errs) {\n                        var finalErrors = [];\n                        if (filledErrors && filledErrors.length) {\n                            finalErrors.push.apply(finalErrors, filledErrors);\n                        }\n                        if (errs && errs.length) {\n                            finalErrors.push.apply(finalErrors, errs);\n                        }\n                        doIt(finalErrors.length ? finalErrors : null);\n                    });\n                }\n            }\n            var res;\n            if (rule.asyncValidator) {\n                res = rule.asyncValidator(rule, data.value, cb, data.source, options);\n            } else if (rule.validator) {\n                try {\n                    res = rule.validator(rule, data.value, cb, data.source, options);\n                } catch (error) {\n                    console.error == null ? void 0 : console.error(error); // rethrow to report error\n                    if (!options.suppressValidatorError) {\n                        setTimeout(function() {\n                            throw error;\n                        }, 0);\n                    }\n                    cb(error.message);\n                }\n                if (res === true) {\n                    cb();\n                } else if (res === false) {\n                    cb(typeof rule.message === \"function\" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + \" fails\");\n                } else if (res instanceof Array) {\n                    cb(res);\n                } else if (res instanceof Error) {\n                    cb(res.message);\n                }\n            }\n            if (res && res.then) {\n                res.then(function() {\n                    return cb();\n                }, function(e) {\n                    return cb(e);\n                });\n            }\n        }, function(results) {\n            complete(results);\n        }, source);\n    };\n    _proto.getType = function getType(rule) {\n        if (rule.type === undefined && rule.pattern instanceof RegExp) {\n            rule.type = \"pattern\";\n        }\n        if (typeof rule.validator !== \"function\" && rule.type && !validators.hasOwnProperty(rule.type)) {\n            throw new Error(format(\"Unknown rule type %s\", rule.type));\n        }\n        return rule.type || \"string\";\n    };\n    _proto.getValidationMethod = function getValidationMethod(rule) {\n        if (typeof rule.validator === \"function\") {\n            return rule.validator;\n        }\n        var keys = Object.keys(rule);\n        var messageIndex = keys.indexOf(\"message\");\n        if (messageIndex !== -1) {\n            keys.splice(messageIndex, 1);\n        }\n        if (keys.length === 1 && keys[0] === \"required\") {\n            return validators.required;\n        }\n        return validators[this.getType(rule)] || undefined;\n    };\n    return Schema;\n}();\nSchema.register = function register(type, validator) {\n    if (typeof validator !== \"function\") {\n        throw new Error(\"Cannot register a validator by type, validator is not a function\");\n    }\n    validators[type] = validator;\n};\nSchema.warning = warning;\nSchema.messages = messages;\nSchema.validators = validators;\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FzeW5jLXZhbGlkYXRvci9kaXN0LXdlYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsU0FBU0E7SUFDUEEsV0FBV0MsT0FBT0MsTUFBTSxHQUFHRCxPQUFPQyxNQUFNLENBQUNDLElBQUksS0FBSyxTQUFVQyxNQUFNO1FBQ2hFLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJQyxVQUFVQyxNQUFNLEVBQUVGLElBQUs7WUFDekMsSUFBSUcsU0FBU0YsU0FBUyxDQUFDRCxFQUFFO1lBRXpCLElBQUssSUFBSUksT0FBT0QsT0FBUTtnQkFDdEIsSUFBSVAsT0FBT1MsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0osUUFBUUMsTUFBTTtvQkFDckRMLE1BQU0sQ0FBQ0ssSUFBSSxHQUFHRCxNQUFNLENBQUNDLElBQUk7Z0JBQzNCO1lBQ0Y7UUFDRjtRQUVBLE9BQU9MO0lBQ1Q7SUFDQSxPQUFPSixTQUFTYSxLQUFLLENBQUMsSUFBSSxFQUFFUDtBQUM5QjtBQUVBLFNBQVNRLGVBQWVDLFFBQVEsRUFBRUMsVUFBVTtJQUMxQ0QsU0FBU0wsU0FBUyxHQUFHVCxPQUFPZ0IsTUFBTSxDQUFDRCxXQUFXTixTQUFTO0lBQ3ZESyxTQUFTTCxTQUFTLENBQUNRLFdBQVcsR0FBR0g7SUFFakNJLGdCQUFnQkosVUFBVUM7QUFDNUI7QUFFQSxTQUFTSSxnQkFBZ0JDLENBQUM7SUFDeEJELGtCQUFrQm5CLE9BQU9xQixjQUFjLEdBQUdyQixPQUFPc0IsY0FBYyxDQUFDcEIsSUFBSSxLQUFLLFNBQVNpQixnQkFBZ0JDLENBQUM7UUFDakcsT0FBT0EsRUFBRUcsU0FBUyxJQUFJdkIsT0FBT3NCLGNBQWMsQ0FBQ0Y7SUFDOUM7SUFDQSxPQUFPRCxnQkFBZ0JDO0FBQ3pCO0FBRUEsU0FBU0YsZ0JBQWdCRSxDQUFDLEVBQUVJLENBQUM7SUFDM0JOLGtCQUFrQmxCLE9BQU9xQixjQUFjLEdBQUdyQixPQUFPcUIsY0FBYyxD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MUQ7UUFFQSxPQUFPb0UsS0FBS3BFLElBQUksSUFBSTtJQUN0QjtJQUVBZ0ssT0FBT2dCLG1CQUFtQixHQUFHLFNBQVNBLG9CQUFvQjVHLElBQUk7UUFDNUQsSUFBSSxPQUFPQSxLQUFLMkcsU0FBUyxLQUFLLFlBQVk7WUFDeEMsT0FBTzNHLEtBQUsyRyxTQUFTO1FBQ3ZCO1FBRUEsSUFBSXBJLE9BQU8zRyxPQUFPMkcsSUFBSSxDQUFDeUI7UUFDdkIsSUFBSXFJLGVBQWU5SixLQUFLOUQsT0FBTyxDQUFDO1FBRWhDLElBQUk0TixpQkFBaUIsQ0FBQyxHQUFHO1lBQ3ZCOUosS0FBSytKLE1BQU0sQ0FBQ0QsY0FBYztRQUM1QjtRQUVBLElBQUk5SixLQUFLckcsTUFBTSxLQUFLLEtBQUtxRyxJQUFJLENBQUMsRUFBRSxLQUFLLFlBQVk7WUFDL0MsT0FBTzJHLFdBQVcxRSxRQUFRO1FBQzVCO1FBRUEsT0FBTzBFLFVBQVUsQ0FBQyxJQUFJLENBQUMyQixPQUFPLENBQUM3RyxNQUFNLElBQUluRjtJQUMzQztJQUVBLE9BQU8ySztBQUNUO0FBRUFBLE9BQU8rQyxRQUFRLEdBQUcsU0FBU0EsU0FBUzNNLElBQUksRUFBRStLLFNBQVM7SUFDakQsSUFBSSxPQUFPQSxjQUFjLFlBQVk7UUFDbkMsTUFBTSxJQUFJL0gsTUFBTTtJQUNsQjtJQUVBc0csVUFBVSxDQUFDdEosS0FBSyxHQUFHK0s7QUFDckI7QUFFQW5CLE9BQU9oSyxPQUFPLEdBQUdBO0FBQ2pCZ0ssT0FBTzlFLFFBQVEsR0FBR0E7QUFDbEI4RSxPQUFPTixVQUFVLEdBQUdBO0FBRVMsQ0FDN0IsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2hlY2tvdXQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FzeW5jLXZhbGlkYXRvci9kaXN0LXdlYi9pbmRleC5qcz9lNWQ4Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuXG4gIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICBpZiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7XG4gICAgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0LmJpbmQoKTtcbiAgfSBlbHNlIHtcbiAgICBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gICAgICB2YXIgYSA9IFtudWxsXTtcbiAgICAgIGEucHVzaC5hcHBseShhLCBhcmdzKTtcbiAgICAgIHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTtcbiAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpO1xuICAgICAgaWYgKENsYXNzKSBfc2V0UHJvdG90eXBlT2YoaW5zdGFuY2UsIENsYXNzLnByb3RvdHlwZSk7XG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZUZ1bmN0aW9uKGZuKSB7XG4gIHJldHVybiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKGZuKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKSAhPT0gLTE7XG59XG5cbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDtcblxuICBfd3JhcE5hdGl2ZVN1cGVyID0gZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykge1xuICAgIGlmIChDbGFzcyA9PT0gbnVsbCB8fCAhX2lzTmF0aXZlRnVuY3Rpb24oQ2xhc3MpKSByZXR1cm4gQ2xhc3M7XG5cbiAgICBpZiAodHlwZW9mIENsYXNzICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIF9jYWNoZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaWYgKF9jYWNoZS5oYXMoQ2xhc3MpKSByZXR1cm4gX2NhY2hlLmdldChDbGFzcyk7XG5cbiAgICAgIF9jYWNoZS5zZXQoQ2xhc3MsIFdyYXBwZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFdyYXBwZXIoKSB7XG4gICAgICByZXR1cm4gX2NvbnN0cnVjdChDbGFzcywgYXJndW1lbnRzLCBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IpO1xuICAgIH1cblxuICAgIFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBXcmFwcGVyLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpO1xuICB9O1xuXG4gIHJldHVybiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKTtcbn1cblxuLyogZXNsaW50IG5vLWNvbnNvbGU6MCAqL1xudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG52YXIgd2FybmluZyA9IGZ1bmN0aW9uIHdhcm5pbmcoKSB7fTsgLy8gZG9uJ3QgcHJpbnQgd2FybmluZyBtZXNzYWdlIHdoZW4gaW4gcHJvZHVjdGlvbiBlbnYgb3Igbm9kZSBydW50aW1lXG5cbmlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gIHdhcm5pbmcgPSBmdW5jdGlvbiB3YXJuaW5nKHR5cGUsIGVycm9ycykge1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS53YXJuICYmIHR5cGVvZiBBU1lOQ19WQUxJREFUT1JfTk9fV0FSTklORyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmIChlcnJvcnMuZXZlcnkoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBlID09PSAnc3RyaW5nJztcbiAgICAgIH0pKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybih0eXBlLCBlcnJvcnMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY29udmVydEZpZWxkc0Vycm9yKGVycm9ycykge1xuICBpZiAoIWVycm9ycyB8fCAhZXJyb3JzLmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gIHZhciBmaWVsZHMgPSB7fTtcbiAgZXJyb3JzLmZvckVhY2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgdmFyIGZpZWxkID0gZXJyb3IuZmllbGQ7XG4gICAgZmllbGRzW2ZpZWxkXSA9IGZpZWxkc1tmaWVsZF0gfHwgW107XG4gICAgZmllbGRzW2ZpZWxkXS5wdXNoKGVycm9yKTtcbiAgfSk7XG4gIHJldHVybiBmaWVsZHM7XG59XG5mdW5jdGlvbiBmb3JtYXQodGVtcGxhdGUpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgdmFyIGkgPSAwO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG5cbiAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0ZW1wbGF0ZS5hcHBseShudWxsLCBhcmdzKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdGVtcGxhdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHN0ciA9IHRlbXBsYXRlLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbiAoeCkge1xuICAgICAgaWYgKHggPT09ICclJScpIHtcbiAgICAgICAgcmV0dXJuICclJztcbiAgICAgIH1cblxuICAgICAgaWYgKGkgPj0gbGVuKSB7XG4gICAgICAgIHJldHVybiB4O1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHgpIHtcbiAgICAgICAgY2FzZSAnJXMnOlxuICAgICAgICAgIHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcblxuICAgICAgICBjYXNlICclZCc6XG4gICAgICAgICAgcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuXG4gICAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB4O1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICByZXR1cm4gdGVtcGxhdGU7XG59XG5cbmZ1bmN0aW9uIGlzTmF0aXZlU3RyaW5nVHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlID09PSAndXJsJyB8fCB0eXBlID09PSAnaGV4JyB8fCB0eXBlID09PSAnZW1haWwnIHx8IHR5cGUgPT09ICdkYXRlJyB8fCB0eXBlID09PSAncGF0dGVybic7XG59XG5cbmZ1bmN0aW9uIGlzRW1wdHlWYWx1ZSh2YWx1ZSwgdHlwZSkge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGUgPT09ICdhcnJheScgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgIXZhbHVlLmxlbmd0aCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGlzTmF0aXZlU3RyaW5nVHlwZSh0eXBlKSAmJiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmICF2YWx1ZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBhc3luY1BhcmFsbGVsQXJyYXkoYXJyLCBmdW5jLCBjYWxsYmFjaykge1xuICB2YXIgcmVzdWx0cyA9IFtdO1xuICB2YXIgdG90YWwgPSAwO1xuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aDtcblxuICBmdW5jdGlvbiBjb3VudChlcnJvcnMpIHtcbiAgICByZXN1bHRzLnB1c2guYXBwbHkocmVzdWx0cywgZXJyb3JzIHx8IFtdKTtcbiAgICB0b3RhbCsrO1xuXG4gICAgaWYgKHRvdGFsID09PSBhcnJMZW5ndGgpIHtcbiAgICAgIGNhbGxiYWNrKHJlc3VsdHMpO1xuICAgIH1cbiAgfVxuXG4gIGFyci5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgZnVuYyhhLCBjb3VudCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhc3luY1NlcmlhbEFycmF5KGFyciwgZnVuYywgY2FsbGJhY2spIHtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGg7XG5cbiAgZnVuY3Rpb24gbmV4dChlcnJvcnMpIHtcbiAgICBpZiAoZXJyb3JzICYmIGVycm9ycy5sZW5ndGgpIHtcbiAgICAgIGNhbGxiYWNrKGVycm9ycyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG9yaWdpbmFsID0gaW5kZXg7XG4gICAgaW5kZXggPSBpbmRleCArIDE7XG5cbiAgICBpZiAob3JpZ2luYWwgPCBhcnJMZW5ndGgpIHtcbiAgICAgIGZ1bmMoYXJyW29yaWdpbmFsXSwgbmV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKFtdKTtcbiAgICB9XG4gIH1cblxuICBuZXh0KFtdKTtcbn1cblxuZnVuY3Rpb24gZmxhdHRlbk9iakFycihvYmpBcnIpIHtcbiAgdmFyIHJldCA9IFtdO1xuICBPYmplY3Qua2V5cyhvYmpBcnIpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICByZXQucHVzaC5hcHBseShyZXQsIG9iakFycltrXSB8fCBbXSk7XG4gIH0pO1xuICByZXR1cm4gcmV0O1xufVxuXG52YXIgQXN5bmNWYWxpZGF0aW9uRXJyb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FcnJvcikge1xuICBfaW5oZXJpdHNMb29zZShBc3luY1ZhbGlkYXRpb25FcnJvciwgX0Vycm9yKTtcblxuICBmdW5jdGlvbiBBc3luY1ZhbGlkYXRpb25FcnJvcihlcnJvcnMsIGZpZWxkcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0Vycm9yLmNhbGwodGhpcywgJ0FzeW5jIFZhbGlkYXRpb24gRXJyb3InKSB8fCB0aGlzO1xuICAgIF90aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICBfdGhpcy5maWVsZHMgPSBmaWVsZHM7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIEFzeW5jVmFsaWRhdGlvbkVycm9yO1xufSggLyojX19QVVJFX18qL193cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcbmZ1bmN0aW9uIGFzeW5jTWFwKG9iakFyciwgb3B0aW9uLCBmdW5jLCBjYWxsYmFjaywgc291cmNlKSB7XG4gIGlmIChvcHRpb24uZmlyc3QpIHtcbiAgICB2YXIgX3BlbmRpbmcgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgbmV4dCA9IGZ1bmN0aW9uIG5leHQoZXJyb3JzKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycm9ycyk7XG4gICAgICAgIHJldHVybiBlcnJvcnMubGVuZ3RoID8gcmVqZWN0KG5ldyBBc3luY1ZhbGlkYXRpb25FcnJvcihlcnJvcnMsIGNvbnZlcnRGaWVsZHNFcnJvcihlcnJvcnMpKSkgOiByZXNvbHZlKHNvdXJjZSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgZmxhdHRlbkFyciA9IGZsYXR0ZW5PYmpBcnIob2JqQXJyKTtcbiAgICAgIGFzeW5jU2VyaWFsQXJyYXkoZmxhdHRlbkFyciwgZnVuYywgbmV4dCk7XG4gICAgfSk7XG5cbiAgICBfcGVuZGluZ1tcImNhdGNoXCJdKGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gZTtcbiAgICB9KTtcblxuICAgIHJldHVybiBfcGVuZGluZztcbiAgfVxuXG4gIHZhciBmaXJzdEZpZWxkcyA9IG9wdGlvbi5maXJzdEZpZWxkcyA9PT0gdHJ1ZSA/IE9iamVjdC5rZXlzKG9iakFycikgOiBvcHRpb24uZmlyc3RGaWVsZHMgfHwgW107XG4gIHZhciBvYmpBcnJLZXlzID0gT2JqZWN0LmtleXMob2JqQXJyKTtcbiAgdmFyIG9iakFyckxlbmd0aCA9IG9iakFycktleXMubGVuZ3RoO1xuICB2YXIgdG90YWwgPSAwO1xuICB2YXIgcmVzdWx0cyA9IFtdO1xuICB2YXIgcGVuZGluZyA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgbmV4dCA9IGZ1bmN0aW9uIG5leHQoZXJyb3JzKSB7XG4gICAgICByZXN1bHRzLnB1c2guYXBwbHkocmVzdWx0cywgZXJyb3JzKTtcbiAgICAgIHRvdGFsKys7XG5cbiAgICAgIGlmICh0b3RhbCA9PT0gb2JqQXJyTGVuZ3RoKSB7XG4gICAgICAgIGNhbGxiYWNrKHJlc3VsdHMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0cy5sZW5ndGggPyByZWplY3QobmV3IEFzeW5jVmFsaWRhdGlvbkVycm9yKHJlc3VsdHMsIGNvbnZlcnRGaWVsZHNFcnJvcihyZXN1bHRzKSkpIDogcmVzb2x2ZShzb3VyY2UpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoIW9iakFycktleXMubGVuZ3RoKSB7XG4gICAgICBjYWxsYmFjayhyZXN1bHRzKTtcbiAgICAgIHJlc29sdmUoc291cmNlKTtcbiAgICB9XG5cbiAgICBvYmpBcnJLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIGFyciA9IG9iakFycltrZXldO1xuXG4gICAgICBpZiAoZmlyc3RGaWVsZHMuaW5kZXhPZihrZXkpICE9PSAtMSkge1xuICAgICAgICBhc3luY1NlcmlhbEFycmF5KGFyciwgZnVuYywgbmV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhc3luY1BhcmFsbGVsQXJyYXkoYXJyLCBmdW5jLCBuZXh0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHBlbmRpbmdbXCJjYXRjaFwiXShmdW5jdGlvbiAoZSkge1xuICAgIHJldHVybiBlO1xuICB9KTtcbiAgcmV0dXJuIHBlbmRpbmc7XG59XG5cbmZ1bmN0aW9uIGlzRXJyb3JPYmoob2JqKSB7XG4gIHJldHVybiAhIShvYmogJiYgb2JqLm1lc3NhZ2UgIT09IHVuZGVmaW5lZCk7XG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlKHZhbHVlLCBwYXRoKSB7XG4gIHZhciB2ID0gdmFsdWU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHYgPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdjtcbiAgICB9XG5cbiAgICB2ID0gdltwYXRoW2ldXTtcbiAgfVxuXG4gIHJldHVybiB2O1xufVxuXG5mdW5jdGlvbiBjb21wbGVtZW50RXJyb3IocnVsZSwgc291cmNlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAob2UpIHtcbiAgICB2YXIgZmllbGRWYWx1ZTtcblxuICAgIGlmIChydWxlLmZ1bGxGaWVsZHMpIHtcbiAgICAgIGZpZWxkVmFsdWUgPSBnZXRWYWx1ZShzb3VyY2UsIHJ1bGUuZnVsbEZpZWxkcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpZWxkVmFsdWUgPSBzb3VyY2Vbb2UuZmllbGQgfHwgcnVsZS5mdWxsRmllbGRdO1xuICAgIH1cblxuICAgIGlmIChpc0Vycm9yT2JqKG9lKSkge1xuICAgICAgb2UuZmllbGQgPSBvZS5maWVsZCB8fCBydWxlLmZ1bGxGaWVsZDtcbiAgICAgIG9lLmZpZWxkVmFsdWUgPSBmaWVsZFZhbHVlO1xuICAgICAgcmV0dXJuIG9lO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBtZXNzYWdlOiB0eXBlb2Ygb2UgPT09ICdmdW5jdGlvbicgPyBvZSgpIDogb2UsXG4gICAgICBmaWVsZFZhbHVlOiBmaWVsZFZhbHVlLFxuICAgICAgZmllbGQ6IG9lLmZpZWxkIHx8IHJ1bGUuZnVsbEZpZWxkXG4gICAgfTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGRlZXBNZXJnZSh0YXJnZXQsIHNvdXJjZSkge1xuICBpZiAoc291cmNlKSB7XG4gICAgZm9yICh2YXIgcyBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkocykpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gc291cmNlW3NdO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0YXJnZXRbc10gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdGFyZ2V0W3NdID0gX2V4dGVuZHMoe30sIHRhcmdldFtzXSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldFtzXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxudmFyIHJlcXVpcmVkJDEgPSBmdW5jdGlvbiByZXF1aXJlZChydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMsIHR5cGUpIHtcbiAgaWYgKHJ1bGUucmVxdWlyZWQgJiYgKCFzb3VyY2UuaGFzT3duUHJvcGVydHkocnVsZS5maWVsZCkgfHwgaXNFbXB0eVZhbHVlKHZhbHVlLCB0eXBlIHx8IHJ1bGUudHlwZSkpKSB7XG4gICAgZXJyb3JzLnB1c2goZm9ybWF0KG9wdGlvbnMubWVzc2FnZXMucmVxdWlyZWQsIHJ1bGUuZnVsbEZpZWxkKSk7XG4gIH1cbn07XG5cbi8qKlxuICogIFJ1bGUgZm9yIHZhbGlkYXRpbmcgd2hpdGVzcGFjZS5cbiAqXG4gKiAgQHBhcmFtIHJ1bGUgVGhlIHZhbGlkYXRpb24gcnVsZS5cbiAqICBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBmaWVsZCBvbiB0aGUgc291cmNlIG9iamVjdC5cbiAqICBAcGFyYW0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IGJlaW5nIHZhbGlkYXRlZC5cbiAqICBAcGFyYW0gZXJyb3JzIEFuIGFycmF5IG9mIGVycm9ycyB0aGF0IHRoaXMgcnVsZSBtYXkgYWRkXG4gKiAgdmFsaWRhdGlvbiBlcnJvcnMgdG8uXG4gKiAgQHBhcmFtIG9wdGlvbnMgVGhlIHZhbGlkYXRpb24gb3B0aW9ucy5cbiAqICBAcGFyYW0gb3B0aW9ucy5tZXNzYWdlcyBUaGUgdmFsaWRhdGlvbiBtZXNzYWdlcy5cbiAqL1xuXG52YXIgd2hpdGVzcGFjZSA9IGZ1bmN0aW9uIHdoaXRlc3BhY2UocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKSB7XG4gIGlmICgvXlxccyskLy50ZXN0KHZhbHVlKSB8fCB2YWx1ZSA9PT0gJycpIHtcbiAgICBlcnJvcnMucHVzaChmb3JtYXQob3B0aW9ucy5tZXNzYWdlcy53aGl0ZXNwYWNlLCBydWxlLmZ1bGxGaWVsZCkpO1xuICB9XG59O1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20va2V2dmEvdXJsLXJlZ2V4L2Jsb2IvbWFzdGVyL2luZGV4LmpzXG52YXIgdXJsUmVnO1xudmFyIGdldFVybFJlZ2V4ID0gKGZ1bmN0aW9uICgpIHtcbiAgaWYgKHVybFJlZykge1xuICAgIHJldHVybiB1cmxSZWc7XG4gIH1cblxuICB2YXIgd29yZCA9ICdbYS1mQS1GXFxcXGQ6XSc7XG5cbiAgdmFyIGIgPSBmdW5jdGlvbiBiKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLmluY2x1ZGVCb3VuZGFyaWVzID8gXCIoPzooPzw9XFxcXHN8XikoPz1cIiArIHdvcmQgKyBcIil8KD88PVwiICsgd29yZCArIFwiKSg/PVxcXFxzfCQpKVwiIDogJyc7XG4gIH07XG5cbiAgdmFyIHY0ID0gJyg/OjI1WzAtNV18MlswLTRdXFxcXGR8MVxcXFxkXFxcXGR8WzEtOV1cXFxcZHxcXFxcZCkoPzpcXFxcLig/OjI1WzAtNV18MlswLTRdXFxcXGR8MVxcXFxkXFxcXGR8WzEtOV1cXFxcZHxcXFxcZCkpezN9JztcbiAgdmFyIHY2c2VnID0gJ1thLWZBLUZcXFxcZF17MSw0fSc7XG4gIHZhciB2NiA9IChcIlxcbig/Olxcbig/OlwiICsgdjZzZWcgKyBcIjopezd9KD86XCIgKyB2NnNlZyArIFwifDopfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDE6MjozOjQ6NTo2Ojc6OiAgMToyOjM6NDo1OjY6Nzo4XFxuKD86XCIgKyB2NnNlZyArIFwiOil7Nn0oPzpcIiArIHY0ICsgXCJ8OlwiICsgdjZzZWcgKyBcInw6KXwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDE6MjozOjQ6NTo2OjogICAgMToyOjM6NDo1OjY6OjggICAxOjI6Mzo0OjU6Njo6OCAgMToyOjM6NDo1OjY6OjEuMi4zLjRcXG4oPzpcIiArIHY2c2VnICsgXCI6KXs1fSg/OjpcIiArIHY0ICsgXCJ8KD86OlwiICsgdjZzZWcgKyBcIil7MSwyfXw6KXwgICAgICAgICAgICAgICAgICAgLy8gMToyOjM6NDo1OjogICAgICAxOjI6Mzo0OjU6Ojc6OCAgIDE6MjozOjQ6NTo6OCAgICAxOjI6Mzo0OjU6Ojc6MS4yLjMuNFxcbig/OlwiICsgdjZzZWcgKyBcIjopezR9KD86KD86OlwiICsgdjZzZWcgKyBcIil7MCwxfTpcIiArIHY0ICsgXCJ8KD86OlwiICsgdjZzZWcgKyBcIil7MSwzfXw6KXwgLy8gMToyOjM6NDo6ICAgICAgICAxOjI6Mzo0Ojo2Ojc6OCAgIDE6MjozOjQ6OjggICAgICAxOjI6Mzo0Ojo2Ojc6MS4yLjMuNFxcbig/OlwiICsgdjZzZWcgKyBcIjopezN9KD86KD86OlwiICsgdjZzZWcgKyBcIil7MCwyfTpcIiArIHY0ICsgXCJ8KD86OlwiICsgdjZzZWcgKyBcIil7MSw0fXw6KXwgLy8gMToyOjM6OiAgICAgICAgICAxOjI6Mzo6NTo2Ojc6OCAgIDE6MjozOjo4ICAgICAgICAxOjI6Mzo6NTo2Ojc6MS4yLjMuNFxcbig/OlwiICsgdjZzZWcgKyBcIjopezJ9KD86KD86OlwiICsgdjZzZWcgKyBcIil7MCwzfTpcIiArIHY0ICsgXCJ8KD86OlwiICsgdjZzZWcgKyBcIil7MSw1fXw6KXwgLy8gMToyOjogICAgICAgICAgICAxOjI6OjQ6NTo2Ojc6OCAgIDE6Mjo6OCAgICAgICAgICAxOjI6OjQ6NTo2Ojc6MS4yLjMuNFxcbig/OlwiICsgdjZzZWcgKyBcIjopezF9KD86KD86OlwiICsgdjZzZWcgKyBcIil7MCw0fTpcIiArIHY0ICsgXCJ8KD86OlwiICsgdjZzZWcgKyBcIil7MSw2fXw6KXwgLy8gMTo6ICAgICAgICAgICAgICAxOjozOjQ6NTo2Ojc6OCAgIDE6OjggICAgICAgICAgICAxOjozOjQ6NTo2Ojc6MS4yLjMuNFxcbig/OjooPzooPzo6XCIgKyB2NnNlZyArIFwiKXswLDV9OlwiICsgdjQgKyBcInwoPzo6XCIgKyB2NnNlZyArIFwiKXsxLDd9fDopKSAgICAgICAgICAgICAvLyA6OjI6Mzo0OjU6Njo3OjggIDo6MjozOjQ6NTo2Ojc6OCAgOjo4ICAgICAgICAgICAgIDo6MS4yLjMuNFxcbikoPzolWzAtOWEtekEtWl17MSx9KT8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAlZXRoMCAgICAgICAgICAgICUxXFxuXCIpLnJlcGxhY2UoL1xccypcXC9cXC8uKiQvZ20sICcnKS5yZXBsYWNlKC9cXG4vZywgJycpLnRyaW0oKTsgLy8gUHJlLWNvbXBpbGUgb25seSB0aGUgZXhhY3QgcmVnZXhlcyBiZWNhdXNlIGFkZGluZyBhIGdsb2JhbCBmbGFnIG1ha2UgcmVnZXhlcyBzdGF0ZWZ1bFxuXG4gIHZhciB2NDZFeGFjdCA9IG5ldyBSZWdFeHAoXCIoPzpeXCIgKyB2NCArIFwiJCl8KD86XlwiICsgdjYgKyBcIiQpXCIpO1xuICB2YXIgdjRleGFjdCA9IG5ldyBSZWdFeHAoXCJeXCIgKyB2NCArIFwiJFwiKTtcbiAgdmFyIHY2ZXhhY3QgPSBuZXcgUmVnRXhwKFwiXlwiICsgdjYgKyBcIiRcIik7XG5cbiAgdmFyIGlwID0gZnVuY3Rpb24gaXAob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMuZXhhY3QgPyB2NDZFeGFjdCA6IG5ldyBSZWdFeHAoXCIoPzpcIiArIGIob3B0aW9ucykgKyB2NCArIGIob3B0aW9ucykgKyBcIil8KD86XCIgKyBiKG9wdGlvbnMpICsgdjYgKyBiKG9wdGlvbnMpICsgXCIpXCIsICdnJyk7XG4gIH07XG5cbiAgaXAudjQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMuZXhhY3QgPyB2NGV4YWN0IDogbmV3IFJlZ0V4cChcIlwiICsgYihvcHRpb25zKSArIHY0ICsgYihvcHRpb25zKSwgJ2cnKTtcbiAgfTtcblxuICBpcC52NiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5leGFjdCA/IHY2ZXhhY3QgOiBuZXcgUmVnRXhwKFwiXCIgKyBiKG9wdGlvbnMpICsgdjYgKyBiKG9wdGlvbnMpLCAnZycpO1xuICB9O1xuXG4gIHZhciBwcm90b2NvbCA9IFwiKD86KD86W2Etel0rOik/Ly8pXCI7XG4gIHZhciBhdXRoID0gJyg/OlxcXFxTKyg/OjpcXFxcUyopP0ApPyc7XG4gIHZhciBpcHY0ID0gaXAudjQoKS5zb3VyY2U7XG4gIHZhciBpcHY2ID0gaXAudjYoKS5zb3VyY2U7XG4gIHZhciBob3N0ID0gXCIoPzooPzpbYS16XFxcXHUwMGExLVxcXFx1ZmZmZjAtOV1bLV9dKikqW2EtelxcXFx1MDBhMS1cXFxcdWZmZmYwLTldKylcIjtcbiAgdmFyIGRvbWFpbiA9IFwiKD86XFxcXC4oPzpbYS16XFxcXHUwMGExLVxcXFx1ZmZmZjAtOV0tKikqW2EtelxcXFx1MDBhMS1cXFxcdWZmZmYwLTldKykqXCI7XG4gIHZhciB0bGQgPSBcIig/OlxcXFwuKD86W2EtelxcXFx1MDBhMS1cXFxcdWZmZmZdezIsfSkpXCI7XG4gIHZhciBwb3J0ID0gJyg/OjpcXFxcZHsyLDV9KT8nO1xuICB2YXIgcGF0aCA9ICcoPzpbLz8jXVteXFxcXHNcIl0qKT8nO1xuICB2YXIgcmVnZXggPSBcIig/OlwiICsgcHJvdG9jb2wgKyBcInx3d3dcXFxcLilcIiArIGF1dGggKyBcIig/OmxvY2FsaG9zdHxcIiArIGlwdjQgKyBcInxcIiArIGlwdjYgKyBcInxcIiArIGhvc3QgKyBkb21haW4gKyB0bGQgKyBcIilcIiArIHBvcnQgKyBwYXRoO1xuICB1cmxSZWcgPSBuZXcgUmVnRXhwKFwiKD86XlwiICsgcmVnZXggKyBcIiQpXCIsICdpJyk7XG4gIHJldHVybiB1cmxSZWc7XG59KTtcblxuLyogZXNsaW50IG1heC1sZW46MCAqL1xuXG52YXIgcGF0dGVybiQyID0ge1xuICAvLyBodHRwOi8vZW1haWxyZWdleC5jb20vXG4gIGVtYWlsOiAvXigoW148PigpXFxbXFxdXFxcXC4sOzpcXHNAXCJdKyhcXC5bXjw+KClcXFtcXF1cXFxcLiw7Olxcc0BcIl0rKSopfChcIi4rXCIpKUAoKFxcW1swLTldezEsM31cXC5bMC05XXsxLDN9XFwuWzAtOV17MSwzfVxcLlswLTldezEsM31dKXwoKFthLXpBLVpcXC0wLTlcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdK1xcLikrW2EtekEtWlxcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl17Mix9KSkkLyxcbiAgLy8gdXJsOiBuZXcgUmVnRXhwKFxuICAvLyAgICdeKD8hbWFpbHRvOikoPzooPzpodHRwfGh0dHBzfGZ0cCk6Ly98Ly8pKD86XFxcXFMrKD86OlxcXFxTKik/QCk/KD86KD86KD86WzEtOV1cXFxcZD98MVxcXFxkXFxcXGR8MlswMV1cXFxcZHwyMlswLTNdKSg/OlxcXFwuKD86MT9cXFxcZHsxLDJ9fDJbMC00XVxcXFxkfDI1WzAtNV0pKXsyfSg/OlxcXFwuKD86WzAtOV1cXFxcZD98MVxcXFxkXFxcXGR8MlswLTRdXFxcXGR8MjVbMC00XSkpfCg/Oig/OlthLXpcXFxcdTAwYTEtXFxcXHVmZmZmMC05XSstKikqW2EtelxcXFx1MDBhMS1cXFxcdWZmZmYwLTldKykoPzpcXFxcLig/OlthLXpcXFxcdTAwYTEtXFxcXHVmZmZmMC05XSstKikqW2EtelxcXFx1MDBhMS1cXFxcdWZmZmYwLTldKykqKD86XFxcXC4oPzpbYS16XFxcXHUwMGExLVxcXFx1ZmZmZl17Mix9KSkpfGxvY2FsaG9zdCkoPzo6XFxcXGR7Miw1fSk/KD86KC98XFxcXD98IylbXlxcXFxzXSopPyQnLFxuICAvLyAgICdpJyxcbiAgLy8gKSxcbiAgaGV4OiAvXiM/KFthLWYwLTldezZ9fFthLWYwLTldezN9KSQvaVxufTtcbnZhciB0eXBlcyA9IHtcbiAgaW50ZWdlcjogZnVuY3Rpb24gaW50ZWdlcih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlcy5udW1iZXIodmFsdWUpICYmIHBhcnNlSW50KHZhbHVlLCAxMCkgPT09IHZhbHVlO1xuICB9LFxuICBcImZsb2F0XCI6IGZ1bmN0aW9uIGZsb2F0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVzLm51bWJlcih2YWx1ZSkgJiYgIXR5cGVzLmludGVnZXIodmFsdWUpO1xuICB9LFxuICBhcnJheTogZnVuY3Rpb24gYXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gIH0sXG4gIHJlZ2V4cDogZnVuY3Rpb24gcmVnZXhwKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuICEhbmV3IFJlZ0V4cCh2YWx1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcbiAgZGF0ZTogZnVuY3Rpb24gZGF0ZSh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUuZ2V0VGltZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuZ2V0TW9udGggPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmdldFllYXIgPT09ICdmdW5jdGlvbicgJiYgIWlzTmFOKHZhbHVlLmdldFRpbWUoKSk7XG4gIH0sXG4gIG51bWJlcjogZnVuY3Rpb24gbnVtYmVyKHZhbHVlKSB7XG4gICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInO1xuICB9LFxuICBvYmplY3Q6IGZ1bmN0aW9uIG9iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICF0eXBlcy5hcnJheSh2YWx1ZSk7XG4gIH0sXG4gIG1ldGhvZDogZnVuY3Rpb24gbWV0aG9kKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgfSxcbiAgZW1haWw6IGZ1bmN0aW9uIGVtYWlsKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUubGVuZ3RoIDw9IDMyMCAmJiAhIXZhbHVlLm1hdGNoKHBhdHRlcm4kMi5lbWFpbCk7XG4gIH0sXG4gIHVybDogZnVuY3Rpb24gdXJsKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUubGVuZ3RoIDw9IDIwNDggJiYgISF2YWx1ZS5tYXRjaChnZXRVcmxSZWdleCgpKTtcbiAgfSxcbiAgaGV4OiBmdW5jdGlvbiBoZXgodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiAhIXZhbHVlLm1hdGNoKHBhdHRlcm4kMi5oZXgpO1xuICB9XG59O1xuXG52YXIgdHlwZSQxID0gZnVuY3Rpb24gdHlwZShydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMpIHtcbiAgaWYgKHJ1bGUucmVxdWlyZWQgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJlcXVpcmVkJDEocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY3VzdG9tID0gWydpbnRlZ2VyJywgJ2Zsb2F0JywgJ2FycmF5JywgJ3JlZ2V4cCcsICdvYmplY3QnLCAnbWV0aG9kJywgJ2VtYWlsJywgJ251bWJlcicsICdkYXRlJywgJ3VybCcsICdoZXgnXTtcbiAgdmFyIHJ1bGVUeXBlID0gcnVsZS50eXBlO1xuXG4gIGlmIChjdXN0b20uaW5kZXhPZihydWxlVHlwZSkgPiAtMSkge1xuICAgIGlmICghdHlwZXNbcnVsZVR5cGVdKHZhbHVlKSkge1xuICAgICAgZXJyb3JzLnB1c2goZm9ybWF0KG9wdGlvbnMubWVzc2FnZXMudHlwZXNbcnVsZVR5cGVdLCBydWxlLmZ1bGxGaWVsZCwgcnVsZS50eXBlKSk7XG4gICAgfSAvLyBzdHJhaWdodCB0eXBlb2YgY2hlY2tcblxuICB9IGVsc2UgaWYgKHJ1bGVUeXBlICYmIHR5cGVvZiB2YWx1ZSAhPT0gcnVsZS50eXBlKSB7XG4gICAgZXJyb3JzLnB1c2goZm9ybWF0KG9wdGlvbnMubWVzc2FnZXMudHlwZXNbcnVsZVR5cGVdLCBydWxlLmZ1bGxGaWVsZCwgcnVsZS50eXBlKSk7XG4gIH1cbn07XG5cbnZhciByYW5nZSA9IGZ1bmN0aW9uIHJhbmdlKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucykge1xuICB2YXIgbGVuID0gdHlwZW9mIHJ1bGUubGVuID09PSAnbnVtYmVyJztcbiAgdmFyIG1pbiA9IHR5cGVvZiBydWxlLm1pbiA9PT0gJ251bWJlcic7XG4gIHZhciBtYXggPSB0eXBlb2YgcnVsZS5tYXggPT09ICdudW1iZXInOyAvLyDmraPliJnljLnphY3noIHngrnojIPlm7Tku45VKzAxMDAwMOS4gOebtOWIsFUrMTBGRkZG55qE5paH5a2X77yI6KGl5YWF5bmz6Z2iU3VwcGxlbWVudGFyeSBQbGFuZe+8iVxuXG4gIHZhciBzcFJlZ2V4cCA9IC9bXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdL2c7XG4gIHZhciB2YWwgPSB2YWx1ZTtcbiAgdmFyIGtleSA9IG51bGw7XG4gIHZhciBudW0gPSB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInO1xuICB2YXIgc3RyID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbiAgdmFyIGFyciA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuXG4gIGlmIChudW0pIHtcbiAgICBrZXkgPSAnbnVtYmVyJztcbiAgfSBlbHNlIGlmIChzdHIpIHtcbiAgICBrZXkgPSAnc3RyaW5nJztcbiAgfSBlbHNlIGlmIChhcnIpIHtcbiAgICBrZXkgPSAnYXJyYXknO1xuICB9IC8vIGlmIHRoZSB2YWx1ZSBpcyBub3Qgb2YgYSBzdXBwb3J0ZWQgdHlwZSBmb3IgcmFuZ2UgdmFsaWRhdGlvblxuICAvLyB0aGUgdmFsaWRhdGlvbiBydWxlIHJ1bGUgc2hvdWxkIHVzZSB0aGVcbiAgLy8gdHlwZSBwcm9wZXJ0eSB0byBhbHNvIHRlc3QgZm9yIGEgcGFydGljdWxhciB0eXBlXG5cblxuICBpZiAoIWtleSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChhcnIpIHtcbiAgICB2YWwgPSB2YWx1ZS5sZW5ndGg7XG4gIH1cblxuICBpZiAoc3RyKSB7XG4gICAgLy8g5aSE55CG56CB54K55aSn5LqOVSswMTAwMDDnmoTmloflrZdsZW5ndGjlsZ7mgKfkuI3lh4bnoa7nmoRidWfvvIzlpoJcIvCgrrfwoK638KCut1wiLmxlbmdodCAhPT0gM1xuICAgIHZhbCA9IHZhbHVlLnJlcGxhY2Uoc3BSZWdleHAsICdfJykubGVuZ3RoO1xuICB9XG5cbiAgaWYgKGxlbikge1xuICAgIGlmICh2YWwgIT09IHJ1bGUubGVuKSB7XG4gICAgICBlcnJvcnMucHVzaChmb3JtYXQob3B0aW9ucy5tZXNzYWdlc1trZXldLmxlbiwgcnVsZS5mdWxsRmllbGQsIHJ1bGUubGVuKSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKG1pbiAmJiAhbWF4ICYmIHZhbCA8IHJ1bGUubWluKSB7XG4gICAgZXJyb3JzLnB1c2goZm9ybWF0KG9wdGlvbnMubWVzc2FnZXNba2V5XS5taW4sIHJ1bGUuZnVsbEZpZWxkLCBydWxlLm1pbikpO1xuICB9IGVsc2UgaWYgKG1heCAmJiAhbWluICYmIHZhbCA+IHJ1bGUubWF4KSB7XG4gICAgZXJyb3JzLnB1c2goZm9ybWF0KG9wdGlvbnMubWVzc2FnZXNba2V5XS5tYXgsIHJ1bGUuZnVsbEZpZWxkLCBydWxlLm1heCkpO1xuICB9IGVsc2UgaWYgKG1pbiAmJiBtYXggJiYgKHZhbCA8IHJ1bGUubWluIHx8IHZhbCA+IHJ1bGUubWF4KSkge1xuICAgIGVycm9ycy5wdXNoKGZvcm1hdChvcHRpb25zLm1lc3NhZ2VzW2tleV0ucmFuZ2UsIHJ1bGUuZnVsbEZpZWxkLCBydWxlLm1pbiwgcnVsZS5tYXgpKTtcbiAgfVxufTtcblxudmFyIEVOVU0kMSA9ICdlbnVtJztcblxudmFyIGVudW1lcmFibGUkMSA9IGZ1bmN0aW9uIGVudW1lcmFibGUocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKSB7XG4gIHJ1bGVbRU5VTSQxXSA9IEFycmF5LmlzQXJyYXkocnVsZVtFTlVNJDFdKSA/IHJ1bGVbRU5VTSQxXSA6IFtdO1xuXG4gIGlmIChydWxlW0VOVU0kMV0uaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XG4gICAgZXJyb3JzLnB1c2goZm9ybWF0KG9wdGlvbnMubWVzc2FnZXNbRU5VTSQxXSwgcnVsZS5mdWxsRmllbGQsIHJ1bGVbRU5VTSQxXS5qb2luKCcsICcpKSk7XG4gIH1cbn07XG5cbnZhciBwYXR0ZXJuJDEgPSBmdW5jdGlvbiBwYXR0ZXJuKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucykge1xuICBpZiAocnVsZS5wYXR0ZXJuKSB7XG4gICAgaWYgKHJ1bGUucGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgLy8gaWYgYSBSZWdFeHAgaW5zdGFuY2UgaXMgcGFzc2VkLCByZXNldCBgbGFzdEluZGV4YCBpbiBjYXNlIGl0cyBgZ2xvYmFsYFxuICAgICAgLy8gZmxhZyBpcyBhY2NpZGVudGFsbHkgc2V0IHRvIGB0cnVlYCwgd2hpY2ggaW4gYSB2YWxpZGF0aW9uIHNjZW5hcmlvXG4gICAgICAvLyBpcyBub3QgbmVjZXNzYXJ5IGFuZCB0aGUgcmVzdWx0IG1pZ2h0IGJlIG1pc2xlYWRpbmdcbiAgICAgIHJ1bGUucGF0dGVybi5sYXN0SW5kZXggPSAwO1xuXG4gICAgICBpZiAoIXJ1bGUucGF0dGVybi50ZXN0KHZhbHVlKSkge1xuICAgICAgICBlcnJvcnMucHVzaChmb3JtYXQob3B0aW9ucy5tZXNzYWdlcy5wYXR0ZXJuLm1pc21hdGNoLCBydWxlLmZ1bGxGaWVsZCwgdmFsdWUsIHJ1bGUucGF0dGVybikpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHJ1bGUucGF0dGVybiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBfcGF0dGVybiA9IG5ldyBSZWdFeHAocnVsZS5wYXR0ZXJuKTtcblxuICAgICAgaWYgKCFfcGF0dGVybi50ZXN0KHZhbHVlKSkge1xuICAgICAgICBlcnJvcnMucHVzaChmb3JtYXQob3B0aW9ucy5tZXNzYWdlcy5wYXR0ZXJuLm1pc21hdGNoLCBydWxlLmZ1bGxGaWVsZCwgdmFsdWUsIHJ1bGUucGF0dGVybikpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIHJ1bGVzID0ge1xuICByZXF1aXJlZDogcmVxdWlyZWQkMSxcbiAgd2hpdGVzcGFjZTogd2hpdGVzcGFjZSxcbiAgdHlwZTogdHlwZSQxLFxuICByYW5nZTogcmFuZ2UsXG4gIFwiZW51bVwiOiBlbnVtZXJhYmxlJDEsXG4gIHBhdHRlcm46IHBhdHRlcm4kMVxufTtcblxudmFyIHN0cmluZyA9IGZ1bmN0aW9uIHN0cmluZyhydWxlLCB2YWx1ZSwgY2FsbGJhY2ssIHNvdXJjZSwgb3B0aW9ucykge1xuICB2YXIgZXJyb3JzID0gW107XG4gIHZhciB2YWxpZGF0ZSA9IHJ1bGUucmVxdWlyZWQgfHwgIXJ1bGUucmVxdWlyZWQgJiYgc291cmNlLmhhc093blByb3BlcnR5KHJ1bGUuZmllbGQpO1xuXG4gIGlmICh2YWxpZGF0ZSkge1xuICAgIGlmIChpc0VtcHR5VmFsdWUodmFsdWUsICdzdHJpbmcnKSAmJiAhcnVsZS5yZXF1aXJlZCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgcnVsZXMucmVxdWlyZWQocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zLCAnc3RyaW5nJyk7XG5cbiAgICBpZiAoIWlzRW1wdHlWYWx1ZSh2YWx1ZSwgJ3N0cmluZycpKSB7XG4gICAgICBydWxlcy50eXBlKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucyk7XG4gICAgICBydWxlcy5yYW5nZShydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMpO1xuICAgICAgcnVsZXMucGF0dGVybihydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMpO1xuXG4gICAgICBpZiAocnVsZS53aGl0ZXNwYWNlID09PSB0cnVlKSB7XG4gICAgICAgIHJ1bGVzLndoaXRlc3BhY2UocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjYWxsYmFjayhlcnJvcnMpO1xufTtcblxudmFyIG1ldGhvZCA9IGZ1bmN0aW9uIG1ldGhvZChydWxlLCB2YWx1ZSwgY2FsbGJhY2ssIHNvdXJjZSwgb3B0aW9ucykge1xuICB2YXIgZXJyb3JzID0gW107XG4gIHZhciB2YWxpZGF0ZSA9IHJ1bGUucmVxdWlyZWQgfHwgIXJ1bGUucmVxdWlyZWQgJiYgc291cmNlLmhhc093blByb3BlcnR5KHJ1bGUuZmllbGQpO1xuXG4gIGlmICh2YWxpZGF0ZSkge1xuICAgIGlmIChpc0VtcHR5VmFsdWUodmFsdWUpICYmICFydWxlLnJlcXVpcmVkKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICBydWxlcy5yZXF1aXJlZChydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMpO1xuXG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJ1bGVzLnR5cGUocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBjYWxsYmFjayhlcnJvcnMpO1xufTtcblxudmFyIG51bWJlciA9IGZ1bmN0aW9uIG51bWJlcihydWxlLCB2YWx1ZSwgY2FsbGJhY2ssIHNvdXJjZSwgb3B0aW9ucykge1xuICB2YXIgZXJyb3JzID0gW107XG4gIHZhciB2YWxpZGF0ZSA9IHJ1bGUucmVxdWlyZWQgfHwgIXJ1bGUucmVxdWlyZWQgJiYgc291cmNlLmhhc093blByb3BlcnR5KHJ1bGUuZmllbGQpO1xuXG4gIGlmICh2YWxpZGF0ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gJycpIHtcbiAgICAgIHZhbHVlID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmIChpc0VtcHR5VmFsdWUodmFsdWUpICYmICFydWxlLnJlcXVpcmVkKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICBydWxlcy5yZXF1aXJlZChydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMpO1xuXG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJ1bGVzLnR5cGUocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcbiAgICAgIHJ1bGVzLnJhbmdlKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgY2FsbGJhY2soZXJyb3JzKTtcbn07XG5cbnZhciBfYm9vbGVhbiA9IGZ1bmN0aW9uIF9ib29sZWFuKHJ1bGUsIHZhbHVlLCBjYWxsYmFjaywgc291cmNlLCBvcHRpb25zKSB7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgdmFyIHZhbGlkYXRlID0gcnVsZS5yZXF1aXJlZCB8fCAhcnVsZS5yZXF1aXJlZCAmJiBzb3VyY2UuaGFzT3duUHJvcGVydHkocnVsZS5maWVsZCk7XG5cbiAgaWYgKHZhbGlkYXRlKSB7XG4gICAgaWYgKGlzRW1wdHlWYWx1ZSh2YWx1ZSkgJiYgIXJ1bGUucmVxdWlyZWQpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIHJ1bGVzLnJlcXVpcmVkKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucyk7XG5cbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcnVsZXMudHlwZShydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIGNhbGxiYWNrKGVycm9ycyk7XG59O1xuXG52YXIgcmVnZXhwID0gZnVuY3Rpb24gcmVnZXhwKHJ1bGUsIHZhbHVlLCBjYWxsYmFjaywgc291cmNlLCBvcHRpb25zKSB7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgdmFyIHZhbGlkYXRlID0gcnVsZS5yZXF1aXJlZCB8fCAhcnVsZS5yZXF1aXJlZCAmJiBzb3VyY2UuaGFzT3duUHJvcGVydHkocnVsZS5maWVsZCk7XG5cbiAgaWYgKHZhbGlkYXRlKSB7XG4gICAgaWYgKGlzRW1wdHlWYWx1ZSh2YWx1ZSkgJiYgIXJ1bGUucmVxdWlyZWQpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIHJ1bGVzLnJlcXVpcmVkKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucyk7XG5cbiAgICBpZiAoIWlzRW1wdHlWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIHJ1bGVzLnR5cGUocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBjYWxsYmFjayhlcnJvcnMpO1xufTtcblxudmFyIGludGVnZXIgPSBmdW5jdGlvbiBpbnRlZ2VyKHJ1bGUsIHZhbHVlLCBjYWxsYmFjaywgc291cmNlLCBvcHRpb25zKSB7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgdmFyIHZhbGlkYXRlID0gcnVsZS5yZXF1aXJlZCB8fCAhcnVsZS5yZXF1aXJlZCAmJiBzb3VyY2UuaGFzT3duUHJvcGVydHkocnVsZS5maWVsZCk7XG5cbiAgaWYgKHZhbGlkYXRlKSB7XG4gICAgaWYgKGlzRW1wdHlWYWx1ZSh2YWx1ZSkgJiYgIXJ1bGUucmVxdWlyZWQpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIHJ1bGVzLnJlcXVpcmVkKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucyk7XG5cbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcnVsZXMudHlwZShydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMpO1xuICAgICAgcnVsZXMucmFuZ2UocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBjYWxsYmFjayhlcnJvcnMpO1xufTtcblxudmFyIGZsb2F0Rm4gPSBmdW5jdGlvbiBmbG9hdEZuKHJ1bGUsIHZhbHVlLCBjYWxsYmFjaywgc291cmNlLCBvcHRpb25zKSB7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgdmFyIHZhbGlkYXRlID0gcnVsZS5yZXF1aXJlZCB8fCAhcnVsZS5yZXF1aXJlZCAmJiBzb3VyY2UuaGFzT3duUHJvcGVydHkocnVsZS5maWVsZCk7XG5cbiAgaWYgKHZhbGlkYXRlKSB7XG4gICAgaWYgKGlzRW1wdHlWYWx1ZSh2YWx1ZSkgJiYgIXJ1bGUucmVxdWlyZWQpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIHJ1bGVzLnJlcXVpcmVkKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucyk7XG5cbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcnVsZXMudHlwZShydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMpO1xuICAgICAgcnVsZXMucmFuZ2UocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBjYWxsYmFjayhlcnJvcnMpO1xufTtcblxudmFyIGFycmF5ID0gZnVuY3Rpb24gYXJyYXkocnVsZSwgdmFsdWUsIGNhbGxiYWNrLCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICB2YXIgdmFsaWRhdGUgPSBydWxlLnJlcXVpcmVkIHx8ICFydWxlLnJlcXVpcmVkICYmIHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShydWxlLmZpZWxkKTtcblxuICBpZiAodmFsaWRhdGUpIHtcbiAgICBpZiAoKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpICYmICFydWxlLnJlcXVpcmVkKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICBydWxlcy5yZXF1aXJlZChydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMsICdhcnJheScpO1xuXG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgIHJ1bGVzLnR5cGUocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcbiAgICAgIHJ1bGVzLnJhbmdlKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgY2FsbGJhY2soZXJyb3JzKTtcbn07XG5cbnZhciBvYmplY3QgPSBmdW5jdGlvbiBvYmplY3QocnVsZSwgdmFsdWUsIGNhbGxiYWNrLCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICB2YXIgdmFsaWRhdGUgPSBydWxlLnJlcXVpcmVkIHx8ICFydWxlLnJlcXVpcmVkICYmIHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShydWxlLmZpZWxkKTtcblxuICBpZiAodmFsaWRhdGUpIHtcbiAgICBpZiAoaXNFbXB0eVZhbHVlKHZhbHVlKSAmJiAhcnVsZS5yZXF1aXJlZCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgcnVsZXMucmVxdWlyZWQocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcblxuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBydWxlcy50eXBlKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgY2FsbGJhY2soZXJyb3JzKTtcbn07XG5cbnZhciBFTlVNID0gJ2VudW0nO1xuXG52YXIgZW51bWVyYWJsZSA9IGZ1bmN0aW9uIGVudW1lcmFibGUocnVsZSwgdmFsdWUsIGNhbGxiYWNrLCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICB2YXIgdmFsaWRhdGUgPSBydWxlLnJlcXVpcmVkIHx8ICFydWxlLnJlcXVpcmVkICYmIHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShydWxlLmZpZWxkKTtcblxuICBpZiAodmFsaWRhdGUpIHtcbiAgICBpZiAoaXNFbXB0eVZhbHVlKHZhbHVlKSAmJiAhcnVsZS5yZXF1aXJlZCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgcnVsZXMucmVxdWlyZWQocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcblxuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBydWxlc1tFTlVNXShydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIGNhbGxiYWNrKGVycm9ycyk7XG59O1xuXG52YXIgcGF0dGVybiA9IGZ1bmN0aW9uIHBhdHRlcm4ocnVsZSwgdmFsdWUsIGNhbGxiYWNrLCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICB2YXIgdmFsaWRhdGUgPSBydWxlLnJlcXVpcmVkIHx8ICFydWxlLnJlcXVpcmVkICYmIHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShydWxlLmZpZWxkKTtcblxuICBpZiAodmFsaWRhdGUpIHtcbiAgICBpZiAoaXNFbXB0eVZhbHVlKHZhbHVlLCAnc3RyaW5nJykgJiYgIXJ1bGUucmVxdWlyZWQpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIHJ1bGVzLnJlcXVpcmVkKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucyk7XG5cbiAgICBpZiAoIWlzRW1wdHlWYWx1ZSh2YWx1ZSwgJ3N0cmluZycpKSB7XG4gICAgICBydWxlcy5wYXR0ZXJuKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgY2FsbGJhY2soZXJyb3JzKTtcbn07XG5cbnZhciBkYXRlID0gZnVuY3Rpb24gZGF0ZShydWxlLCB2YWx1ZSwgY2FsbGJhY2ssIHNvdXJjZSwgb3B0aW9ucykge1xuICAvLyBjb25zb2xlLmxvZygnaW50ZWdlciBydWxlIGNhbGxlZCAlaicsIHJ1bGUpO1xuICB2YXIgZXJyb3JzID0gW107XG4gIHZhciB2YWxpZGF0ZSA9IHJ1bGUucmVxdWlyZWQgfHwgIXJ1bGUucmVxdWlyZWQgJiYgc291cmNlLmhhc093blByb3BlcnR5KHJ1bGUuZmllbGQpOyAvLyBjb25zb2xlLmxvZygndmFsaWRhdGUgb24gJXMgdmFsdWUnLCB2YWx1ZSk7XG5cbiAgaWYgKHZhbGlkYXRlKSB7XG4gICAgaWYgKGlzRW1wdHlWYWx1ZSh2YWx1ZSwgJ2RhdGUnKSAmJiAhcnVsZS5yZXF1aXJlZCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgcnVsZXMucmVxdWlyZWQocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcblxuICAgIGlmICghaXNFbXB0eVZhbHVlKHZhbHVlLCAnZGF0ZScpKSB7XG4gICAgICB2YXIgZGF0ZU9iamVjdDtcblxuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICBkYXRlT2JqZWN0ID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRlT2JqZWN0ID0gbmV3IERhdGUodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBydWxlcy50eXBlKHJ1bGUsIGRhdGVPYmplY3QsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcblxuICAgICAgaWYgKGRhdGVPYmplY3QpIHtcbiAgICAgICAgcnVsZXMucmFuZ2UocnVsZSwgZGF0ZU9iamVjdC5nZXRUaW1lKCksIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjYWxsYmFjayhlcnJvcnMpO1xufTtcblxudmFyIHJlcXVpcmVkID0gZnVuY3Rpb24gcmVxdWlyZWQocnVsZSwgdmFsdWUsIGNhbGxiYWNrLCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICB2YXIgdHlwZSA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gJ2FycmF5JyA6IHR5cGVvZiB2YWx1ZTtcbiAgcnVsZXMucmVxdWlyZWQocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zLCB0eXBlKTtcbiAgY2FsbGJhY2soZXJyb3JzKTtcbn07XG5cbnZhciB0eXBlID0gZnVuY3Rpb24gdHlwZShydWxlLCB2YWx1ZSwgY2FsbGJhY2ssIHNvdXJjZSwgb3B0aW9ucykge1xuICB2YXIgcnVsZVR5cGUgPSBydWxlLnR5cGU7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgdmFyIHZhbGlkYXRlID0gcnVsZS5yZXF1aXJlZCB8fCAhcnVsZS5yZXF1aXJlZCAmJiBzb3VyY2UuaGFzT3duUHJvcGVydHkocnVsZS5maWVsZCk7XG5cbiAgaWYgKHZhbGlkYXRlKSB7XG4gICAgaWYgKGlzRW1wdHlWYWx1ZSh2YWx1ZSwgcnVsZVR5cGUpICYmICFydWxlLnJlcXVpcmVkKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICBydWxlcy5yZXF1aXJlZChydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMsIHJ1bGVUeXBlKTtcblxuICAgIGlmICghaXNFbXB0eVZhbHVlKHZhbHVlLCBydWxlVHlwZSkpIHtcbiAgICAgIHJ1bGVzLnR5cGUocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBjYWxsYmFjayhlcnJvcnMpO1xufTtcblxudmFyIGFueSA9IGZ1bmN0aW9uIGFueShydWxlLCB2YWx1ZSwgY2FsbGJhY2ssIHNvdXJjZSwgb3B0aW9ucykge1xuICB2YXIgZXJyb3JzID0gW107XG4gIHZhciB2YWxpZGF0ZSA9IHJ1bGUucmVxdWlyZWQgfHwgIXJ1bGUucmVxdWlyZWQgJiYgc291cmNlLmhhc093blByb3BlcnR5KHJ1bGUuZmllbGQpO1xuXG4gIGlmICh2YWxpZGF0ZSkge1xuICAgIGlmIChpc0VtcHR5VmFsdWUodmFsdWUpICYmICFydWxlLnJlcXVpcmVkKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICBydWxlcy5yZXF1aXJlZChydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMpO1xuICB9XG5cbiAgY2FsbGJhY2soZXJyb3JzKTtcbn07XG5cbnZhciB2YWxpZGF0b3JzID0ge1xuICBzdHJpbmc6IHN0cmluZyxcbiAgbWV0aG9kOiBtZXRob2QsXG4gIG51bWJlcjogbnVtYmVyLFxuICBcImJvb2xlYW5cIjogX2Jvb2xlYW4sXG4gIHJlZ2V4cDogcmVnZXhwLFxuICBpbnRlZ2VyOiBpbnRlZ2VyLFxuICBcImZsb2F0XCI6IGZsb2F0Rm4sXG4gIGFycmF5OiBhcnJheSxcbiAgb2JqZWN0OiBvYmplY3QsXG4gIFwiZW51bVwiOiBlbnVtZXJhYmxlLFxuICBwYXR0ZXJuOiBwYXR0ZXJuLFxuICBkYXRlOiBkYXRlLFxuICB1cmw6IHR5cGUsXG4gIGhleDogdHlwZSxcbiAgZW1haWw6IHR5cGUsXG4gIHJlcXVpcmVkOiByZXF1aXJlZCxcbiAgYW55OiBhbnlcbn07XG5cbmZ1bmN0aW9uIG5ld01lc3NhZ2VzKCkge1xuICByZXR1cm4ge1xuICAgIFwiZGVmYXVsdFwiOiAnVmFsaWRhdGlvbiBlcnJvciBvbiBmaWVsZCAlcycsXG4gICAgcmVxdWlyZWQ6ICclcyBpcyByZXF1aXJlZCcsXG4gICAgXCJlbnVtXCI6ICclcyBtdXN0IGJlIG9uZSBvZiAlcycsXG4gICAgd2hpdGVzcGFjZTogJyVzIGNhbm5vdCBiZSBlbXB0eScsXG4gICAgZGF0ZToge1xuICAgICAgZm9ybWF0OiAnJXMgZGF0ZSAlcyBpcyBpbnZhbGlkIGZvciBmb3JtYXQgJXMnLFxuICAgICAgcGFyc2U6ICclcyBkYXRlIGNvdWxkIG5vdCBiZSBwYXJzZWQsICVzIGlzIGludmFsaWQgJyxcbiAgICAgIGludmFsaWQ6ICclcyBkYXRlICVzIGlzIGludmFsaWQnXG4gICAgfSxcbiAgICB0eXBlczoge1xuICAgICAgc3RyaW5nOiAnJXMgaXMgbm90IGEgJXMnLFxuICAgICAgbWV0aG9kOiAnJXMgaXMgbm90IGEgJXMgKGZ1bmN0aW9uKScsXG4gICAgICBhcnJheTogJyVzIGlzIG5vdCBhbiAlcycsXG4gICAgICBvYmplY3Q6ICclcyBpcyBub3QgYW4gJXMnLFxuICAgICAgbnVtYmVyOiAnJXMgaXMgbm90IGEgJXMnLFxuICAgICAgZGF0ZTogJyVzIGlzIG5vdCBhICVzJyxcbiAgICAgIFwiYm9vbGVhblwiOiAnJXMgaXMgbm90IGEgJXMnLFxuICAgICAgaW50ZWdlcjogJyVzIGlzIG5vdCBhbiAlcycsXG4gICAgICBcImZsb2F0XCI6ICclcyBpcyBub3QgYSAlcycsXG4gICAgICByZWdleHA6ICclcyBpcyBub3QgYSB2YWxpZCAlcycsXG4gICAgICBlbWFpbDogJyVzIGlzIG5vdCBhIHZhbGlkICVzJyxcbiAgICAgIHVybDogJyVzIGlzIG5vdCBhIHZhbGlkICVzJyxcbiAgICAgIGhleDogJyVzIGlzIG5vdCBhIHZhbGlkICVzJ1xuICAgIH0sXG4gICAgc3RyaW5nOiB7XG4gICAgICBsZW46ICclcyBtdXN0IGJlIGV4YWN0bHkgJXMgY2hhcmFjdGVycycsXG4gICAgICBtaW46ICclcyBtdXN0IGJlIGF0IGxlYXN0ICVzIGNoYXJhY3RlcnMnLFxuICAgICAgbWF4OiAnJXMgY2Fubm90IGJlIGxvbmdlciB0aGFuICVzIGNoYXJhY3RlcnMnLFxuICAgICAgcmFuZ2U6ICclcyBtdXN0IGJlIGJldHdlZW4gJXMgYW5kICVzIGNoYXJhY3RlcnMnXG4gICAgfSxcbiAgICBudW1iZXI6IHtcbiAgICAgIGxlbjogJyVzIG11c3QgZXF1YWwgJXMnLFxuICAgICAgbWluOiAnJXMgY2Fubm90IGJlIGxlc3MgdGhhbiAlcycsXG4gICAgICBtYXg6ICclcyBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuICVzJyxcbiAgICAgIHJhbmdlOiAnJXMgbXVzdCBiZSBiZXR3ZWVuICVzIGFuZCAlcydcbiAgICB9LFxuICAgIGFycmF5OiB7XG4gICAgICBsZW46ICclcyBtdXN0IGJlIGV4YWN0bHkgJXMgaW4gbGVuZ3RoJyxcbiAgICAgIG1pbjogJyVzIGNhbm5vdCBiZSBsZXNzIHRoYW4gJXMgaW4gbGVuZ3RoJyxcbiAgICAgIG1heDogJyVzIGNhbm5vdCBiZSBncmVhdGVyIHRoYW4gJXMgaW4gbGVuZ3RoJyxcbiAgICAgIHJhbmdlOiAnJXMgbXVzdCBiZSBiZXR3ZWVuICVzIGFuZCAlcyBpbiBsZW5ndGgnXG4gICAgfSxcbiAgICBwYXR0ZXJuOiB7XG4gICAgICBtaXNtYXRjaDogJyVzIHZhbHVlICVzIGRvZXMgbm90IG1hdGNoIHBhdHRlcm4gJXMnXG4gICAgfSxcbiAgICBjbG9uZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICB2YXIgY2xvbmVkID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzKSk7XG4gICAgICBjbG9uZWQuY2xvbmUgPSB0aGlzLmNsb25lO1xuICAgICAgcmV0dXJuIGNsb25lZDtcbiAgICB9XG4gIH07XG59XG52YXIgbWVzc2FnZXMgPSBuZXdNZXNzYWdlcygpO1xuXG4vKipcbiAqICBFbmNhcHN1bGF0ZXMgYSB2YWxpZGF0aW9uIHNjaGVtYS5cbiAqXG4gKiAgQHBhcmFtIGRlc2NyaXB0b3IgQW4gb2JqZWN0IGRlY2xhcmluZyB2YWxpZGF0aW9uIHJ1bGVzXG4gKiAgZm9yIHRoaXMgc2NoZW1hLlxuICovXG5cbnZhciBTY2hlbWEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09IFN0YXRpYyA9PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PSBJbnN0YW5jZSA9PT09PT09PT09PT09PT09PT09PT09PT1cbiAgZnVuY3Rpb24gU2NoZW1hKGRlc2NyaXB0b3IpIHtcbiAgICB0aGlzLnJ1bGVzID0gbnVsbDtcbiAgICB0aGlzLl9tZXNzYWdlcyA9IG1lc3NhZ2VzO1xuICAgIHRoaXMuZGVmaW5lKGRlc2NyaXB0b3IpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFNjaGVtYS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmRlZmluZSA9IGZ1bmN0aW9uIGRlZmluZShydWxlcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAoIXJ1bGVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb25maWd1cmUgYSBzY2hlbWEgd2l0aCBubyBydWxlcycpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcnVsZXMgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkocnVsZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1J1bGVzIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgdGhpcy5ydWxlcyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKHJ1bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgaXRlbSA9IHJ1bGVzW25hbWVdO1xuICAgICAgX3RoaXMucnVsZXNbbmFtZV0gPSBBcnJheS5pc0FycmF5KGl0ZW0pID8gaXRlbSA6IFtpdGVtXTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ubWVzc2FnZXMgPSBmdW5jdGlvbiBtZXNzYWdlcyhfbWVzc2FnZXMpIHtcbiAgICBpZiAoX21lc3NhZ2VzKSB7XG4gICAgICB0aGlzLl9tZXNzYWdlcyA9IGRlZXBNZXJnZShuZXdNZXNzYWdlcygpLCBfbWVzc2FnZXMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9tZXNzYWdlcztcbiAgfTtcblxuICBfcHJvdG8udmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZShzb3VyY2VfLCBvLCBvYykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgaWYgKG8gPT09IHZvaWQgMCkge1xuICAgICAgbyA9IHt9O1xuICAgIH1cblxuICAgIGlmIChvYyA9PT0gdm9pZCAwKSB7XG4gICAgICBvYyA9IGZ1bmN0aW9uIG9jKCkge307XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZSA9IHNvdXJjZV87XG4gICAgdmFyIG9wdGlvbnMgPSBvO1xuICAgIHZhciBjYWxsYmFjayA9IG9jO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnJ1bGVzIHx8IE9iamVjdC5rZXlzKHRoaXMucnVsZXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc291cmNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wbGV0ZShyZXN1bHRzKSB7XG4gICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICB2YXIgZmllbGRzID0ge307XG5cbiAgICAgIGZ1bmN0aW9uIGFkZChlKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgICAgICAgdmFyIF9lcnJvcnM7XG5cbiAgICAgICAgICBlcnJvcnMgPSAoX2Vycm9ycyA9IGVycm9ycykuY29uY2F0LmFwcGx5KF9lcnJvcnMsIGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVycm9ycy5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhZGQocmVzdWx0c1tpXSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICBjYWxsYmFjayhudWxsLCBzb3VyY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmllbGRzID0gY29udmVydEZpZWxkc0Vycm9yKGVycm9ycyk7XG4gICAgICAgIGNhbGxiYWNrKGVycm9ycywgZmllbGRzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5tZXNzYWdlcykge1xuICAgICAgdmFyIG1lc3NhZ2VzJDEgPSB0aGlzLm1lc3NhZ2VzKCk7XG5cbiAgICAgIGlmIChtZXNzYWdlcyQxID09PSBtZXNzYWdlcykge1xuICAgICAgICBtZXNzYWdlcyQxID0gbmV3TWVzc2FnZXMoKTtcbiAgICAgIH1cblxuICAgICAgZGVlcE1lcmdlKG1lc3NhZ2VzJDEsIG9wdGlvbnMubWVzc2FnZXMpO1xuICAgICAgb3B0aW9ucy5tZXNzYWdlcyA9IG1lc3NhZ2VzJDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMubWVzc2FnZXMgPSB0aGlzLm1lc3NhZ2VzKCk7XG4gICAgfVxuXG4gICAgdmFyIHNlcmllcyA9IHt9O1xuICAgIHZhciBrZXlzID0gb3B0aW9ucy5rZXlzIHx8IE9iamVjdC5rZXlzKHRoaXMucnVsZXMpO1xuICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoeikge1xuICAgICAgdmFyIGFyciA9IF90aGlzMi5ydWxlc1t6XTtcbiAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVt6XTtcbiAgICAgIGFyci5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIHZhciBydWxlID0gcjtcblxuICAgICAgICBpZiAodHlwZW9mIHJ1bGUudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgaWYgKHNvdXJjZSA9PT0gc291cmNlXykge1xuICAgICAgICAgICAgc291cmNlID0gX2V4dGVuZHMoe30sIHNvdXJjZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFsdWUgPSBzb3VyY2Vbel0gPSBydWxlLnRyYW5zZm9ybSh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJ1bGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBydWxlID0ge1xuICAgICAgICAgICAgdmFsaWRhdG9yOiBydWxlXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBydWxlID0gX2V4dGVuZHMoe30sIHJ1bGUpO1xuICAgICAgICB9IC8vIEZpbGwgdmFsaWRhdG9yLiBTa2lwIGlmIG5vdGhpbmcgbmVlZCB0byB2YWxpZGF0ZVxuXG5cbiAgICAgICAgcnVsZS52YWxpZGF0b3IgPSBfdGhpczIuZ2V0VmFsaWRhdGlvbk1ldGhvZChydWxlKTtcblxuICAgICAgICBpZiAoIXJ1bGUudmFsaWRhdG9yKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcnVsZS5maWVsZCA9IHo7XG4gICAgICAgIHJ1bGUuZnVsbEZpZWxkID0gcnVsZS5mdWxsRmllbGQgfHwgejtcbiAgICAgICAgcnVsZS50eXBlID0gX3RoaXMyLmdldFR5cGUocnVsZSk7XG4gICAgICAgIHNlcmllc1t6XSA9IHNlcmllc1t6XSB8fCBbXTtcbiAgICAgICAgc2VyaWVzW3pdLnB1c2goe1xuICAgICAgICAgIHJ1bGU6IHJ1bGUsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgIGZpZWxkOiB6XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdmFyIGVycm9yRmllbGRzID0ge307XG4gICAgcmV0dXJuIGFzeW5jTWFwKHNlcmllcywgb3B0aW9ucywgZnVuY3Rpb24gKGRhdGEsIGRvSXQpIHtcbiAgICAgIHZhciBydWxlID0gZGF0YS5ydWxlO1xuICAgICAgdmFyIGRlZXAgPSAocnVsZS50eXBlID09PSAnb2JqZWN0JyB8fCBydWxlLnR5cGUgPT09ICdhcnJheScpICYmICh0eXBlb2YgcnVsZS5maWVsZHMgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBydWxlLmRlZmF1bHRGaWVsZCA9PT0gJ29iamVjdCcpO1xuICAgICAgZGVlcCA9IGRlZXAgJiYgKHJ1bGUucmVxdWlyZWQgfHwgIXJ1bGUucmVxdWlyZWQgJiYgZGF0YS52YWx1ZSk7XG4gICAgICBydWxlLmZpZWxkID0gZGF0YS5maWVsZDtcblxuICAgICAgZnVuY3Rpb24gYWRkRnVsbEZpZWxkKGtleSwgc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc2NoZW1hLCB7XG4gICAgICAgICAgZnVsbEZpZWxkOiBydWxlLmZ1bGxGaWVsZCArIFwiLlwiICsga2V5LFxuICAgICAgICAgIGZ1bGxGaWVsZHM6IHJ1bGUuZnVsbEZpZWxkcyA/IFtdLmNvbmNhdChydWxlLmZ1bGxGaWVsZHMsIFtrZXldKSA6IFtrZXldXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjYihlKSB7XG4gICAgICAgIGlmIChlID09PSB2b2lkIDApIHtcbiAgICAgICAgICBlID0gW107XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXJyb3JMaXN0ID0gQXJyYXkuaXNBcnJheShlKSA/IGUgOiBbZV07XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLnN1cHByZXNzV2FybmluZyAmJiBlcnJvckxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgU2NoZW1hLndhcm5pbmcoJ2FzeW5jLXZhbGlkYXRvcjonLCBlcnJvckxpc3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yTGlzdC5sZW5ndGggJiYgcnVsZS5tZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBlcnJvckxpc3QgPSBbXS5jb25jYXQocnVsZS5tZXNzYWdlKTtcbiAgICAgICAgfSAvLyBGaWxsIGVycm9yIGluZm9cblxuXG4gICAgICAgIHZhciBmaWxsZWRFcnJvcnMgPSBlcnJvckxpc3QubWFwKGNvbXBsZW1lbnRFcnJvcihydWxlLCBzb3VyY2UpKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5maXJzdCAmJiBmaWxsZWRFcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgZXJyb3JGaWVsZHNbcnVsZS5maWVsZF0gPSAxO1xuICAgICAgICAgIHJldHVybiBkb0l0KGZpbGxlZEVycm9ycyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWRlZXApIHtcbiAgICAgICAgICBkb0l0KGZpbGxlZEVycm9ycyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaWYgcnVsZSBpcyByZXF1aXJlZCBidXQgdGhlIHRhcmdldCBvYmplY3RcbiAgICAgICAgICAvLyBkb2VzIG5vdCBleGlzdCBmYWlsIGF0IHRoZSBydWxlIGxldmVsIGFuZCBkb24ndFxuICAgICAgICAgIC8vIGdvIGRlZXBlclxuICAgICAgICAgIGlmIChydWxlLnJlcXVpcmVkICYmICFkYXRhLnZhbHVlKSB7XG4gICAgICAgICAgICBpZiAocnVsZS5tZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgZmlsbGVkRXJyb3JzID0gW10uY29uY2F0KHJ1bGUubWVzc2FnZSkubWFwKGNvbXBsZW1lbnRFcnJvcihydWxlLCBzb3VyY2UpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5lcnJvcikge1xuICAgICAgICAgICAgICBmaWxsZWRFcnJvcnMgPSBbb3B0aW9ucy5lcnJvcihydWxlLCBmb3JtYXQob3B0aW9ucy5tZXNzYWdlcy5yZXF1aXJlZCwgcnVsZS5maWVsZCkpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRvSXQoZmlsbGVkRXJyb3JzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZmllbGRzU2NoZW1hID0ge307XG5cbiAgICAgICAgICBpZiAocnVsZS5kZWZhdWx0RmllbGQpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGRhdGEudmFsdWUpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgIGZpZWxkc1NjaGVtYVtrZXldID0gcnVsZS5kZWZhdWx0RmllbGQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmaWVsZHNTY2hlbWEgPSBfZXh0ZW5kcyh7fSwgZmllbGRzU2NoZW1hLCBkYXRhLnJ1bGUuZmllbGRzKTtcbiAgICAgICAgICB2YXIgcGFyZWRGaWVsZHNTY2hlbWEgPSB7fTtcbiAgICAgICAgICBPYmplY3Qua2V5cyhmaWVsZHNTY2hlbWEpLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgICB2YXIgZmllbGRTY2hlbWEgPSBmaWVsZHNTY2hlbWFbZmllbGRdO1xuICAgICAgICAgICAgdmFyIGZpZWxkU2NoZW1hTGlzdCA9IEFycmF5LmlzQXJyYXkoZmllbGRTY2hlbWEpID8gZmllbGRTY2hlbWEgOiBbZmllbGRTY2hlbWFdO1xuICAgICAgICAgICAgcGFyZWRGaWVsZHNTY2hlbWFbZmllbGRdID0gZmllbGRTY2hlbWFMaXN0Lm1hcChhZGRGdWxsRmllbGQuYmluZChudWxsLCBmaWVsZCkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBzY2hlbWEgPSBuZXcgU2NoZW1hKHBhcmVkRmllbGRzU2NoZW1hKTtcbiAgICAgICAgICBzY2hlbWEubWVzc2FnZXMob3B0aW9ucy5tZXNzYWdlcyk7XG5cbiAgICAgICAgICBpZiAoZGF0YS5ydWxlLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIGRhdGEucnVsZS5vcHRpb25zLm1lc3NhZ2VzID0gb3B0aW9ucy5tZXNzYWdlcztcbiAgICAgICAgICAgIGRhdGEucnVsZS5vcHRpb25zLmVycm9yID0gb3B0aW9ucy5lcnJvcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzY2hlbWEudmFsaWRhdGUoZGF0YS52YWx1ZSwgZGF0YS5ydWxlLm9wdGlvbnMgfHwgb3B0aW9ucywgZnVuY3Rpb24gKGVycnMpIHtcbiAgICAgICAgICAgIHZhciBmaW5hbEVycm9ycyA9IFtdO1xuXG4gICAgICAgICAgICBpZiAoZmlsbGVkRXJyb3JzICYmIGZpbGxlZEVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgZmluYWxFcnJvcnMucHVzaC5hcHBseShmaW5hbEVycm9ycywgZmlsbGVkRXJyb3JzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVycnMgJiYgZXJycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgZmluYWxFcnJvcnMucHVzaC5hcHBseShmaW5hbEVycm9ycywgZXJycyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRvSXQoZmluYWxFcnJvcnMubGVuZ3RoID8gZmluYWxFcnJvcnMgOiBudWxsKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcmVzO1xuXG4gICAgICBpZiAocnVsZS5hc3luY1ZhbGlkYXRvcikge1xuICAgICAgICByZXMgPSBydWxlLmFzeW5jVmFsaWRhdG9yKHJ1bGUsIGRhdGEudmFsdWUsIGNiLCBkYXRhLnNvdXJjZSwgb3B0aW9ucyk7XG4gICAgICB9IGVsc2UgaWYgKHJ1bGUudmFsaWRhdG9yKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzID0gcnVsZS52YWxpZGF0b3IocnVsZSwgZGF0YS52YWx1ZSwgY2IsIGRhdGEuc291cmNlLCBvcHRpb25zKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yID09IG51bGwgPyB2b2lkIDAgOiBjb25zb2xlLmVycm9yKGVycm9yKTsgLy8gcmV0aHJvdyB0byByZXBvcnQgZXJyb3JcblxuICAgICAgICAgIGlmICghb3B0aW9ucy5zdXBwcmVzc1ZhbGlkYXRvckVycm9yKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYihlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXMgPT09IHRydWUpIHtcbiAgICAgICAgICBjYigpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBjYih0eXBlb2YgcnVsZS5tZXNzYWdlID09PSAnZnVuY3Rpb24nID8gcnVsZS5tZXNzYWdlKHJ1bGUuZnVsbEZpZWxkIHx8IHJ1bGUuZmllbGQpIDogcnVsZS5tZXNzYWdlIHx8IChydWxlLmZ1bGxGaWVsZCB8fCBydWxlLmZpZWxkKSArIFwiIGZhaWxzXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlcyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgY2IocmVzKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXMgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIGNiKHJlcy5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocmVzICYmIHJlcy50aGVuKSB7XG4gICAgICAgIHJlcy50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY2IoKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICByZXR1cm4gY2IoZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIChyZXN1bHRzKSB7XG4gICAgICBjb21wbGV0ZShyZXN1bHRzKTtcbiAgICB9LCBzb3VyY2UpO1xuICB9O1xuXG4gIF9wcm90by5nZXRUeXBlID0gZnVuY3Rpb24gZ2V0VHlwZShydWxlKSB7XG4gICAgaWYgKHJ1bGUudHlwZSA9PT0gdW5kZWZpbmVkICYmIHJ1bGUucGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgcnVsZS50eXBlID0gJ3BhdHRlcm4nO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcnVsZS52YWxpZGF0b3IgIT09ICdmdW5jdGlvbicgJiYgcnVsZS50eXBlICYmICF2YWxpZGF0b3JzLmhhc093blByb3BlcnR5KHJ1bGUudHlwZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihmb3JtYXQoJ1Vua25vd24gcnVsZSB0eXBlICVzJywgcnVsZS50eXBlKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJ1bGUudHlwZSB8fCAnc3RyaW5nJztcbiAgfTtcblxuICBfcHJvdG8uZ2V0VmFsaWRhdGlvbk1ldGhvZCA9IGZ1bmN0aW9uIGdldFZhbGlkYXRpb25NZXRob2QocnVsZSkge1xuICAgIGlmICh0eXBlb2YgcnVsZS52YWxpZGF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBydWxlLnZhbGlkYXRvcjtcbiAgICB9XG5cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJ1bGUpO1xuICAgIHZhciBtZXNzYWdlSW5kZXggPSBrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKTtcblxuICAgIGlmIChtZXNzYWdlSW5kZXggIT09IC0xKSB7XG4gICAgICBrZXlzLnNwbGljZShtZXNzYWdlSW5kZXgsIDEpO1xuICAgIH1cblxuICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMSAmJiBrZXlzWzBdID09PSAncmVxdWlyZWQnKSB7XG4gICAgICByZXR1cm4gdmFsaWRhdG9ycy5yZXF1aXJlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsaWRhdG9yc1t0aGlzLmdldFR5cGUocnVsZSldIHx8IHVuZGVmaW5lZDtcbiAgfTtcblxuICByZXR1cm4gU2NoZW1hO1xufSgpO1xuXG5TY2hlbWEucmVnaXN0ZXIgPSBmdW5jdGlvbiByZWdpc3Rlcih0eXBlLCB2YWxpZGF0b3IpIHtcbiAgaWYgKHR5cGVvZiB2YWxpZGF0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWdpc3RlciBhIHZhbGlkYXRvciBieSB0eXBlLCB2YWxpZGF0b3IgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIHZhbGlkYXRvcnNbdHlwZV0gPSB2YWxpZGF0b3I7XG59O1xuXG5TY2hlbWEud2FybmluZyA9IHdhcm5pbmc7XG5TY2hlbWEubWVzc2FnZXMgPSBtZXNzYWdlcztcblNjaGVtYS52YWxpZGF0b3JzID0gdmFsaWRhdG9ycztcblxuZXhwb3J0IHsgU2NoZW1hIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbIl9leHRlbmRzIiwiT2JqZWN0IiwiYXNzaWduIiwiYmluZCIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhcHBseSIsIl9pbmhlcml0c0xvb3NlIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiY3JlYXRlIiwiY29uc3RydWN0b3IiLCJfc2V0UHJvdG90eXBlT2YiLCJfZ2V0UHJvdG90eXBlT2YiLCJvIiwic2V0UHJvdG90eXBlT2YiLCJnZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsInAiLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiUmVmbGVjdCIsImNvbnN0cnVjdCIsInNoYW0iLCJQcm94eSIsIkJvb2xlYW4iLCJ2YWx1ZU9mIiwiZSIsIl9jb25zdHJ1Y3QiLCJQYXJlbnQiLCJhcmdzIiwiQ2xhc3MiLCJhIiwicHVzaCIsIkNvbnN0cnVjdG9yIiwiRnVuY3Rpb24iLCJpbnN0YW5jZSIsIl9pc05hdGl2ZUZ1bmN0aW9uIiwiZm4iLCJ0b1N0cmluZyIsImluZGV4T2YiLCJfd3JhcE5hdGl2ZVN1cGVyIiwiX2NhY2hlIiwiTWFwIiwidW5kZWZpbmVkIiwiVHlwZUVycm9yIiwiaGFzIiwiZ2V0Iiwic2V0IiwiV3JhcHBlciIsInZhbHVlIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiZm9ybWF0UmVnRXhwIiwid2FybmluZyIsInByb2Nlc3MiLCJlbnYiLCJkb2N1bWVudCIsInR5cGUiLCJlcnJvcnMiLCJjb25zb2xlIiwid2FybiIsIkFTWU5DX1ZBTElEQVRPUl9OT19XQVJOSU5HIiwiZXZlcnkiLCJjb252ZXJ0RmllbGRzRXJyb3IiLCJmaWVsZHMiLCJmb3JFYWNoIiwiZXJyb3IiLCJmaWVsZCIsImZvcm1hdCIsInRlbXBsYXRlIiwiX2xlbiIsIkFycmF5IiwiX2tleSIsImxlbiIsInN0ciIsInJlcGxhY2UiLCJ4IiwiU3RyaW5nIiwiTnVtYmVyIiwiSlNPTiIsInN0cmluZ2lmeSIsIl8iLCJpc05hdGl2ZVN0cmluZ1R5cGUiLCJpc0VtcHR5VmFsdWUiLCJpc0FycmF5IiwiYXN5bmNQYXJhbGxlbEFycmF5IiwiYXJyIiwiZnVuYyIsImNhbGxiYWNrIiwicmVzdWx0cyIsInRvdGFsIiwiYXJyTGVuZ3RoIiwiY291bnQiLCJhc3luY1NlcmlhbEFycmF5IiwiaW5kZXgiLCJuZXh0Iiwib3JpZ2luYWwiLCJmbGF0dGVuT2JqQXJyIiwib2JqQXJyIiwicmV0Iiwia2V5cyIsImsiLCJBc3luY1ZhbGlkYXRpb25FcnJvciIsIl9FcnJvciIsIl90aGlzIiwiRXJyb3IiLCJhc3luY01hcCIsIm9wdGlvbiIsImZpcnN0IiwiX3BlbmRpbmciLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImZsYXR0ZW5BcnIiLCJmaXJzdEZpZWxkcyIsIm9iakFycktleXMiLCJvYmpBcnJMZW5ndGgiLCJwZW5kaW5nIiwiaXNFcnJvck9iaiIsIm9iaiIsIm1lc3NhZ2UiLCJnZXRWYWx1ZSIsInBhdGgiLCJ2IiwiY29tcGxlbWVudEVycm9yIiwicnVsZSIsIm9lIiwiZmllbGRWYWx1ZSIsImZ1bGxGaWVsZHMiLCJmdWxsRmllbGQiLCJkZWVwTWVyZ2UiLCJzIiwicmVxdWlyZWQkMSIsInJlcXVpcmVkIiwib3B0aW9ucyIsIm1lc3NhZ2VzIiwid2hpdGVzcGFjZSIsInRlc3QiLCJ1cmxSZWciLCJnZXRVcmxSZWdleCIsIndvcmQiLCJiIiwiaW5jbHVkZUJvdW5kYXJpZXMiLCJ2NCIsInY2c2VnIiwidjYiLCJ0cmltIiwidjQ2RXhhY3QiLCJSZWdFeHAiLCJ2NGV4YWN0IiwidjZleGFjdCIsImlwIiwiZXhhY3QiLCJwcm90b2NvbCIsImF1dGgiLCJpcHY0IiwiaXB2NiIsImhvc3QiLCJkb21haW4iLCJ0bGQiLCJwb3J0IiwicmVnZXgiLCJwYXR0ZXJuJDIiLCJlbWFpbCIsImhleCIsInR5cGVzIiwiaW50ZWdlciIsIm51bWJlciIsInBhcnNlSW50IiwiZmxvYXQiLCJhcnJheSIsInJlZ2V4cCIsImRhdGUiLCJnZXRUaW1lIiwiZ2V0TW9udGgiLCJnZXRZZWFyIiwiaXNOYU4iLCJvYmplY3QiLCJtZXRob2QiLCJtYXRjaCIsInVybCIsInR5cGUkMSIsImN1c3RvbSIsInJ1bGVUeXBlIiwicmFuZ2UiLCJtaW4iLCJtYXgiLCJzcFJlZ2V4cCIsInZhbCIsIm51bSIsIkVOVU0kMSIsImVudW1lcmFibGUkMSIsImpvaW4iLCJwYXR0ZXJuJDEiLCJwYXR0ZXJuIiwibGFzdEluZGV4IiwibWlzbWF0Y2giLCJfcGF0dGVybiIsInJ1bGVzIiwic3RyaW5nIiwidmFsaWRhdGUiLCJfYm9vbGVhbiIsImZsb2F0Rm4iLCJFTlVNIiwiZGF0ZU9iamVjdCIsIkRhdGUiLCJhbnkiLCJ2YWxpZGF0b3JzIiwibmV3TWVzc2FnZXMiLCJwYXJzZSIsImludmFsaWQiLCJjbG9uZSIsImNsb25lZCIsIlNjaGVtYSIsImRlc2NyaXB0b3IiLCJfbWVzc2FnZXMiLCJkZWZpbmUiLCJfcHJvdG8iLCJuYW1lIiwiaXRlbSIsInNvdXJjZV8iLCJvYyIsIl90aGlzMiIsImNvbXBsZXRlIiwiYWRkIiwiX2Vycm9ycyIsImNvbmNhdCIsIm1lc3NhZ2VzJDEiLCJzZXJpZXMiLCJ6IiwiciIsInRyYW5zZm9ybSIsInZhbGlkYXRvciIsImdldFZhbGlkYXRpb25NZXRob2QiLCJnZXRUeXBlIiwiZXJyb3JGaWVsZHMiLCJkYXRhIiwiZG9JdCIsImRlZXAiLCJkZWZhdWx0RmllbGQiLCJhZGRGdWxsRmllbGQiLCJzY2hlbWEiLCJjYiIsImVycm9yTGlzdCIsInN1cHByZXNzV2FybmluZyIsImZpbGxlZEVycm9ycyIsIm1hcCIsImZpZWxkc1NjaGVtYSIsInBhcmVkRmllbGRzU2NoZW1hIiwiZmllbGRTY2hlbWEiLCJmaWVsZFNjaGVtYUxpc3QiLCJlcnJzIiwiZmluYWxFcnJvcnMiLCJyZXMiLCJhc3luY1ZhbGlkYXRvciIsInN1cHByZXNzVmFsaWRhdG9yRXJyb3IiLCJzZXRUaW1lb3V0IiwidGhlbiIsIm1lc3NhZ2VJbmRleCIsInNwbGljZSIsInJlZ2lzdGVyIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../../node_modules/async-validator/dist-web/index.js\n");

/***/ })

};
;